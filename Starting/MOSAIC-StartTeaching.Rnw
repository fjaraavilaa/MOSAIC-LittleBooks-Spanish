\documentclass[openany]{tufte-book}

\usepackage{../include/RBook}
\usepackage{pdfpages}
%\usepackage[shownotes]{authNote}
\usepackage[hidenotes]{../include/authNote}
\usepackage{../include/language}    % available at https://github.com/rpruim/latex
\usepackage{hyperref}
\usepackage{fancyhdr} % DTK added for header.
\usepackage{enumitem}
\raggedbottom

% Larger font sizes (from size12.clo)
\makeatletter% allows us to use macros with @ in their names
\renewcommand\normalsize{%
   \@setfontsize\normalsize\@xiipt{14.5}%
   \abovedisplayskip 12\p@ \@plus3\p@ \@minus7\p@
   \abovedisplayshortskip \z@ \@plus3\p@
   \belowdisplayshortskip 6.5\p@ \@plus3.5\p@ \@minus3\p@
   \belowdisplayskip \abovedisplayskip
   \let\@listi\@listI}
\renewcommand\small{%
   \@setfontsize\small\@xipt{13.6}%
   \abovedisplayskip 11\p@ \@plus3\p@ \@minus6\p@
   \abovedisplayshortskip \z@ \@plus3\p@
   \belowdisplayshortskip 6.5\p@ \@plus3.5\p@ \@minus3\p@
   \def\@listi{\leftmargin\leftmargini
               \topsep 9\p@ \@plus3\p@ \@minus5\p@
               \parsep 4.5\p@ \@plus2\p@ \@minus\p@
               \itemsep \parsep}%
   \belowdisplayskip \abovedisplayskip
}
\renewcommand\footnotesize{%
   \@setfontsize\footnotesize\@xpt\@xiipt
   \abovedisplayskip 10\p@ \@plus2\p@ \@minus5\p@
   \abovedisplayshortskip \z@ \@plus3\p@
   \belowdisplayshortskip 6\p@ \@plus3\p@ \@minus3\p@
   \def\@listi{\leftmargin\leftmargini
               \topsep 6\p@ \@plus2\p@ \@minus2\p@
               \parsep 3\p@ \@plus2\p@ \@minus\p@
               \itemsep \parsep}%
   \belowdisplayskip \abovedisplayskip
}
\renewcommand\scriptsize{\@setfontsize\scriptsize\@viiipt{9.5}}
\renewcommand\tiny{\@setfontsize\tiny\@vipt\@viipt}
\renewcommand\large{\@setfontsize\large\@xivpt{18}}
\renewcommand\Large{\@setfontsize\Large\@xviipt{22}}
\renewcommand\LARGE{\@setfontsize\LARGE\@xxpt{25}}
\renewcommand\huge{\@setfontsize\huge\@xxvpt{30}}
\let\Huge=\huge
\setlength\leftmargini   {1.5em}
\setlength\leftmarginii  {1.5em}
\setlength\leftmarginiii {1.5em}
\setlength\leftmarginiv  {1.5em}
\setlength\leftmarginv   {1.5em}
\setlength\leftmarginvi  {1.5em}
\setlength\labelsep      {.5pc}
\setlength\labelwidth    {\leftmargini}
\addtolength\labelwidth{-\labelsep}
\setlength{\parindent}{1.5em}%
\renewcommand{\@tufte@reset@par}{%
  \setlength{\RaggedRightParindent}{1.5em}%
  \setlength{\JustifyingParindent}{1.5em}%
  \setlength{\parindent}{1.5em}%
  \setlength{\parskip}{0pt}%
}
\@tufte@reset@par
\renewcommand{\@tufte@margin@par}{%
  \setlength{\RaggedRightParindent}{1.0em}%
  \setlength{\JustifyingParindent}{1.0em}%
  \setlength{\parindent}{1.0em}%
  \setlength{\parskip}{0pt}%
}
\makeatother% restores meaning of @

% For the printed version.  Commented out for Web version
\renewcommand{\variable}[1]{{\color{black}\texttt{#1}}}
\renewcommand{\dataframe}[1]{{\color{black}\texttt{#1}}}
\renewcommand{\function}[1]{{\color{blue}\texttt{\StrSubstitute{#1}{()}{}()}}}
\renewcommand{\option}[1]{{\color{black}\texttt{#1}}}
\renewcommand{\pkg}[1]{{\color{black}\texttt{#1}}}
\renewcommand{\code}[1]{{\color{black}\texttt{#1}}}



\title{Empiece a enseñar con R}
\author[Pruim, Horton \& Kaplan]{Randall Pruim, Nicholas J. Horton, and Daniel T. Kaplan}
\date{Enero 2015}

\begin{document}
\def\cplabel{^X} 

\def\tilde{\texttt{\~}}
% stupid hack to get rid of unwanted space before next line when there is not
% a blank line following an R chunk.
\renewenvironment{knitrout}{}{\noindent\ignorespaces\!\!}

<<include=FALSE, echo=FALSE>>=
#setCacheDir("cache")
require(MASS)
require(grDevices) 
require(datasets) 
require(stats) 
require(lattice)
require(grid) 
# require(fastR)	# commented out by NH on 7/12/2012
require(mosaic) 
require(mosaicData)
require(knitr)
trellis.par.set(theme=col.mosaic(bw=FALSE))
trellis.par.set(fontsize=list(text=9))
options(format.R.blank=FALSE) 
options(width=60)
options(digits=3)
require(vcd)
require(evaluate)
@

<<include=FALSE, echo=FALSE>>=
includeChapter <- FALSE # don't show chapters not yet being paginated.
showEdited <- FALSE  # displaying chapters already paginated for printing
knit_hooks$set(document = function(x) { 
			   sub('\\usepackage[]{color}', '\\usepackage[]{xcolor}', 
			   x, fixed = TRUE) 
}) 

#knit_hooks$set(document = function(x) { 
#  gsub('(\\\\end\\{knitrout\\})\n', '\\1', x) 
#}) 
@



\maketitle

\includepdf{frontice}

\newpage
\vspace*{2in}

\parbox{4in}{\noindent Copyright (c) 2015 by Randall Pruim, Nicholas J. Horton, \& Daniel T. Kaplan.}
\medskip

\parbox{4in}{\noindent Edition 1.1, November 2015}

\bigskip

\parbox{4in}{\noindent This material is copyrighted by the authors under a Creative Commons Attribution 3.0 Unported License. You are free to \emph{Share} (to copy, distribute and transmit the work) and to \emph{Remix} (to adapt the work) if you attribute our work. More detailed information about the licensing is available at this web page:
\url{http://www.mosaic-web.org/go/teachingRlicense.html}.
}


\vspace*{2.in}

\parbox{4in}{\noindent {\bf Cover Photo}: Maya Hanna}

\newpage

\hspace{1.3cm}\parbox{8in}{\tableofcontents}

\newpage

\chapter*{Acerca de estas notas}
<<include=FALSE, message=FALSE, echo=FALSE>>=
opts_chunk$set( fig.path="figures/FrontMatter-" ) 
set.seed(123)
@
Aquí presentamos un abordaje a la enseñanza introductoria e intermedia en cursos de estadística, la cual está acoplada importantemente con la computación general, y con \R\ y \RStudio\ RStudio en particular. Estas actividades y ejemplos tienen la intención de resaltar el abordaje moderno de la enseñanza estadística que se concentra en el modelaje, la inferencia basada en el re-muestreo y las técnicas de gráficos multivariados. Una meta secundaria es facilitar los cálculos con datos mediante el uso de pequeños estudios de simulaciones y el flujo de trabajo de análisis estadístico apropiado. Esto sigue la filosofía descrita por Nolan y Temple Lang1\cite{nola:temp:2010}. La importancia de la computación moderna \marginnote{$\ $} en la educación estadística consiste en que esta es un componente principal de los  lineamientos de currículo recientemente adoptados de la Asociación Americana de Estadística\cite{ASAcurriculum2014}.

En este libro (y en sus volúmenes acompañantes), introduciremos múltiples actividades, algunas apropiadas para un curso introductorio, otras maleables para niveles superiores, que demuestran conceptos claves de estadística y modelaje, mientras también ofrecen ayuda al material de base de cursos más tradicionales.

\subsection*{Un trabajo en progreso}

\Caution{A pesar de nuestros mejores esfuerzos, VA a encontrar fallas en este documento y en nuestro código. Por favor háganos saber cuándo las encuentre para poder resolverlas..}%

Estos materiales fueron construidos para un taller llamado
\emph{Teaching Statistics Using R} (Enseñando estadística con R) anterior a la  United States Conference on Teaching Statistics y fue corregido para USCOTS 2011, USCOTS 2013, eCOTS 2014, ICOTS 9, and USCOTS 2015.

Organizamos todos estos talleres para ayudar a los instructores a integrar \R\ R (así como otras tecnologías relacionadas) en los cursos de estadística de todos los niveles.

Recibimos una gran retroalimentación y bastantes buenas ideas por parte de participantes y por parte de aquellos con los que compartimos este material en 
los talleres.

Considere las notas como un trabajo en progreso.
%\SuggestionBox{En ocasiones vamos a marcar 
%partes en las cuales nos gustaría retroalimentación con este buzón de sugerencias
%Pero no lo haremos en todas las secciones que queremos retroalimentación porque si no,
% no tendríamos espacio para nada más.}%
Apreciaremos cualquier retroalimentación que esté dispuesto a compartirnos, conforme continuamos el trabajo en estos materiales y el acompañante del material, el paquete \pkg{mosaic}.  
Envíenos un email a \url{pis@mosaic-web.org} con cualquier comentario, sugerencia, corrección, etc

Versiones actualizadas del paquete serán publicadas en  \url{http://mosaic-web.org}.

\subsection*{Dos audiencias}

Inicialmente desarrollamos estos materiales para instructores y profesores de estadística a nivel universitario. Otra audiencia para la cual desarrollamos el material son los estudiantes a quién estos instructores o profesores enseñan. Algunas de las secciones, algunos de los ejemplos y  algunos ejercicios están pensados para una u otra de estas audiencias, con una mayor claridad en el énfasis que se le da a la audiencia. Esto significa que:
\begin{enumerate}
\item Algunos materiales son utilizados esencialmente para los estudiantes.
\item Algunos materiales apuntan a equipar al instructor a explotar sus propias capacidades en \R\ and \RStudio\ para desarrollar su propio material de enseñanza.
\end{enumerate}

Aunque la distinción puede volverse confusa, y lo que funciona "así" en una condición puede no funcionar "así" en otras, intentaremos indicarle cuales partes se ajustan  a cual audiencia conforme vayamos por ella.

\subsection*{R, RStudio y los paquetes de R}

\R\ puede ser obtenido  \url{http://cran.r-project.org/}.  
La descarga e instalación es abierta y sencilla para máquinas con MAC, PC o linux

\RStudio\ es una interfaz de desarrollo integrada (IDE por sus siglas en inglés) que facilita el uso de \R\ tanto para usuarios sin experiencia como usuarios expertos.  Lo hemos adaptado como nuestra interfaz standard de enseñanza puesto que simplifica drásticamente el uso de \R\ para instructores y estudiantes.%


\RStudio\ está disponible en \url{http://www.rstudio.org/}.


\RStudio\ . RStudio puede instalarse como aplicación de escritorio o como una aplicación en un servidor accesible a los usuarios vía Internet.\Pointer[-3cm]{Algunas cosas sólo pueden ser ejecutadas en RStudio, como la función \function{manipulate} y la herramienta de RStudio para la investigación reproducible.}%
\FoodForThought[-.5cm]{La versión en un servidor web de RStudio funciona bien con estudiantes que están iniciando. Lo único que se  necesita es un navegador web, evadiendo todos los potenciales problemas con particularidades de la computadora personal de cada estudiante.}

Además de \R\ y \RStudio\, haremos uso de algunos paquetes que necesitan ser instalados y cargados separadamente. El paquete \pkg{mosaic} (y sus dependencias) serán utilizados en todo momento. Otros paquetes aparecerán esporádicamente.
\subsection*{Notas marginales}
Las notas marginales aparecerán por aquí y por allá
%\DiggingDeeper{Some marginal notes will look like this one and provide
%some additional information that you may find of interest.}%
\marginnote{¿Tiene alguna sugerencia para una nota marginal? Compártala con nosotros.}%
En ocasiones estas son comentarios extra que deseábamos hacer, pero no queríamos interrumpir el flujo de la lectura y mencionarlos en el texto principal. Otras proveen consejos para la enseñanza o precauciones acerca de trampas, caídas y 'jugadas'.
%\Caution{Sin embargo, las alertas están ajustadas diferentes, asegúrese de prestarles atención.}%

\subsection*{Lo que es nuestro, es suyo, hasta cierto punto}
Este material se encuentra en copyright por los autores, bajo 'Creative Commons Attribution 3.0 Unported License'.
Está libre para \emph{compartirlo} (copiarlo, distribuirlo y transferir el trabajo) y \emph{mezclarlo} 
(adaptar el trabajo) si nos atribuye el  trabajo realizado.
Para información más detallada sobre esto, está disponible en el siguiente sitio web:
\url{http://www.mosaic-web.org/go/teachingRlicense.html}.


\DiggingDeeper{Si usted conoce LaTeX tan bien como R, entonces el paquete knitr ofrece una buena solución para mezclar ambos. Nosotros utilizamos este sistema para producir este libro. También lo utilizamos para nuestra propia investigación y para introducir a estudiantes de nivel superior a métodos de análisis reproducible. Para principiantes, introducimos knitr con RMarkdown, el cual produce archivos en formato PDF, HTML o Word utilizando sintaxis sencilla}

\subsection*{Creación del documento}

El documento original fue creado el 12 de Agosto de 2016, utilizando: knitr, versión 1.13.2 mosaic, versión 0.14.9000 *R version 3.3.0 (2016-05-03)

Inevitablemente, cada una de estas va ser actualizada en ciertas ocasiones. Si usted encuentra cosas que se ven diferente en su computadora, asegúrese que su versión de \R{} y sus paquetes estén actualizados y revise versiones más nuevas de este documento

Honores y agradecimientos a Joseph Cappelleri por sus comentarios útiles en los primeros borradores de este material

\chapter{Proyecto MOSAIC}
Este libro es producto del Proyecto MOSAIC, una comunidad de educadores trabajando para desarrollar nuevas formas de introducir las matemáticas, la estadística, la computación y el modelaje de datos a estudiantes universitarios.

\bigskip

La meta del proyecto MOSAIC es ayudar a compartir ideas y recursos para mejorar la enseñanza, y desarrollar una estructura curricular y valorativa para dar apoyo a la diseminación y evaluación de estos esfuerzos. Nuestra meta es proveer un amplio acercamiento a los estudios cuantitativos que brindan una mejor herramienta al trabajo en la ciencia y tecnología. El proyecto resalta e integra diversos aspectos del trabajo cuantitativo que los estudiantes de ciencia, tecnología e ingeniería necesitarán en sus vidas profesionales, pero que actualmente es usual que sean enseñados de forma aislada, si es que acaso se enseñan. En particular, nos concentramos en:

\vspace{.1in}

En particular nos enfocamos en:
\begin{description}
	\item[Modelaje] La habilidad de crear, manipular e investigar representaciones matemáticas útiles e informativas de situaciones del mundo real.

	\item[Estadística] El análisis de variabilidad que se esboza de nuestra habilidad de cuantificar la incertidumbre y generar inferencias lógicas de observación y experimentación.

    \item[Computación] 
	La capacidad de pensar algorítmicamente, de manejar datos en gran escala, visualizar e interactuar con modelos, y automatizar tareas para la eficiencia, precisión y reproducibilidad.

    \item[Cálculo] 
	El punto de entrada tradicional para estudiantes universitarios y un tema que todavía hoy tiene la capacidad de dotar de nociones importantes a los estudiantes
	\end{description}

Tomando el apoyo de la Fundación Nacional de Ciencia de Estados Unidos (NSF DUE-0920350), 
Proyecto MOSAIC apoya algunas iniciativas para ayudar a lograr estas metas, 
incluyendo:
\begin{description}
\item
[Desarrollo de facultades y oportunidad de entrenamiento] 
así como en USCOTS 2011, USCOTS 2013, eCOTS 2014, e ICOTS9 en los talleres
\emph{'Teaching Statistics Using \R\ y \RStudio}, en 2010 nuestro Proyecto MOSAIC inició talleres en el Instituto de Matemática y sus aplicaciones, y nuestro taller  \emph{Modeling: Early and Often in Undergraduate Calculus}
AMS PREP fueron ofrecidos en 2012,  2013, and 2015.

\item
[M-casts,] 
una serie de seminarios web programados regularmente, dados vía Internet,  
en el que se creó foro para que los instructores puedan compartir sus observaciones e innovaciones 
y desarrollar colaboraciones para refinar y desarrollar las mismas.
Las grabaciones de los M-casts están
disponibles en el sitio web del Proyecto MOSAIC, \url{http://mosaic-web.org}.
\item[La construcción de un programa y materiales] 
para cursos que enseña MOSAIC con tópicos integrados de la mejor manera. Estos
Estos cursos y materiales podrían ser completamente nuevas construcciones,
o podrían ser modificaciones de 
recursos existentes que se aproximen 
a las conexiones entre los tópicos de MOSAIC.
\end{description}

Más detalles pueden ser encontrados en \url{http://www.mosaic-web.org}.
Le damos la bienvenida e incitamos su participación en todas estas iniciativas.

\chapter*{Estadística computacional}

Hay al menos dos formas en las cuales se puede introducir un software
estadístico en un curso de estadística.  En el primer abordaje, el curso debe ser enseñado esencialmente como 
se hacía anterior a la utilización de los software estadísticos, pero utilizando la computadora para hacer más rápidos algunos cálculos y generar gráficos de alta calidad displays.  PProbablemente el tamaño de los conjuntos de datos también deba ser incrementado. Nos referiremos a este enfoque como
\term{computación estadística} 
puesto que la computadora funciona primariamente como una herramienta de cálculo para reemplazar los cálculos en lápiz y papel, además del dibujo manual de los gráficos.

En el segundo abordaje, cambios más importantes en el curso resultan de la introducción de la computadora. Algunos temas nuevos son cubiertos, algunos temas anteriores son omitidos. Algunos temas anteriores son tratados en formas muy diferentes, y quizás en diferentes etapas en el curso.  A este abordaje nos referiremos como \term{estadística computacional} bporque la disponibilidad de la computación está moldeando como la estadística es construida y enseñada. La estadística computacional es un componente clave de la  \term{ciencia de los datos}, definida como la habilidad de usar datos para responder preguntas y comunicar resultados.

\FoodForThought{Los estudiantes necesitan ver los aspectos de la computación y la ciencia de los datos de manera pronta y cotidiana para desarrollar habilidades profundas. Establecer bases en cursos introductorios ayuda a que inicien de mejor manera.}%

En la práctica, la mayoría de los cursos van a incorporar elementos de ambas, la estadística computacional y la computación estadística, pero las proporciones relativas pueden diferir drásticamente de curso a curso. En qué parte del espectro se encuentra el curso va depender de muchos factores, incluyendo las metas del curso, la disponibilidad de tecnología para el uso de los estudiantes, la perspectiva del libro utilizado y el nivel de 'comfort' que sienta el instructor con la estadística y la computación.

Entre los varios paquetes de software estadístico disponible, \R\ está incrementando su popularidad. La reciente adición de \RStudio\ ha hecho R más poderoso y accesible. Como \R\ y \RStudio\ son gratis, ambos se han vuelto ampliamente utilizados en la investigación y la industria. Entrenar en \R\ y \RStudio\ es normalmente visto como una habilidad adicional importante que un curso de estadística puede desarrollar. Por esto, un alto número de instructores están utilizando \R\ para su propio trabajo estadístico; por lo que es natural que inicien a integrarlo en la enseñanza también. Al mismo tiempo, el desarrollo de \R\ y \RStudio\ (una interfaz opcional e integrada al desarrollo de un entorno para \R) están haciendo cada vez más fácil iniciar la utilización de \R.

\FoodForThought{La información sobre el paquete \pkg{mosaic}, incluyendo ejemplos de características y material suplementario (así como este libro) puede encontrarla en \url{https://cran.r-project.org/web/packages/mosaic}.}
Desarrollamos el paquete de \R\ \pkg{mosaic} (disponible en CRAN), para hacer ciertos aspectos de la computación estadística y la estadística computacional más simple para inexpertos, sin limitar su habilidad a utilizar características del lenguaje.  El paquete \pkg{mosaic} incluye un acercamiento al modelaje, que utiliza la misma sintaxis general para calcular estadísticas descriptivas, crear gráficos y ajustar modelos lineales.


\chapter{Algunos Consejos para empezar con R}
<<echo=FALSE,include=FALSE>>=
opts_chunk$set( fig.path="figures/GettingStarted-" ) 
@ 
Aprender \R\ es un proceso gradual, arrancar de buena forma asegura que al final del camino todo sea un éxito. En este capítulo discutimos sobre estrategias y técnicas para empezar a enseñar estadística con \R.
\marginnote{El paquete \pkg{mosaic} incluye una viñeta resumiendo una serie de comandos de \R\ para enseñar un curso introductorio.}%
En los capítulos siguientes, le brindaremos más detalles acerca de (los pocos) comandos que los estudiantes necesitan saber, además de alguna información necesaria que es útil que los instructores sepan. En el camino, presentamos algunos de nuestros ejemplos favoritos que resalta el uso de \R\, incluyendo algunos que pueden ser utilizados muy pronto en el curso.

%\authNote{add a pointer to the 1 page handout somewhere?}


\section{Estrategias}
Cada instructor elige como empezar su curso, sin embargo, nosotros ofrecemos las siguientes estrategias (seguidas por tácticas y ejemplos) que pueden servir como guía para empezar el curso de forma que prepare a los estudiantes exitosamente con \R.
\begin{enumerate}
\item	
Empiece lo más pronto posible.

Haga algo con él en el día 1. Haga algo más en el día 2. Haga que los estudiantes hagan algo para el final de la semana 1.


\item Ilustre frecuentemente.

\TeachingTip[-2cm]{RMarkdown proporciona una forma fácil de crear documentos o diapositivas para sus estudiantes. Para más información sobre la integración de RMarkdown en su curso, vea
\href{http://arxiv.org/abs/1402.1894}%
{\emph{R Markdown: Integrating a Reproducible Analysis Tool into Introductory Statistics}}
por B Baumer \emph{et al}.
Para aquellos que ya esten familiarizados con \LaTeX, también existe una forma de integrar \pkg{knitr}/\LaTeX en \RStudio.}
Tenga R ejecutándose en todo momento de clase y utilícelo conforme sea necesario durante el curso, así los estudiantes pueden ver lo que R hace. Presente los temas antes de pedirle a los estudiantes hacer algo.

\item
Enseñe \R\ como un lenguaje (Pero no abuse de ello). 

Hay un poco de sintaxis que se debe aprender -- entonces enséñela de forma explícita
\begin{itemize}
\item
Enfatice que la utilización de mayúsculas y minúsculas, así como la ortografía cuentan
\item
Explique con mucho cuidado (y repetidamente) la sintaxis de las funciones. 

Afortunadamente la sintaxis es muy directa. 
Esta consiste en el nombre de una función, seguido por un paréntesis abierto, seguido por listas de argumento, seguido por el paréntesis de cierre
<<eval=FALSE>>=
functionname ( name1=arg1, name2=arg2, ... )
@
Haga que los estudientes piensen que hace la función y que necesita saber para que lo haga. Generalmente el nombre de la función indica qué hace la función. Los argumentos le dan a la función la información necesaria para que haga su tarea.
\item
Hay diferentes tipos de objeto en R.  Pregunte frecuentemente: \emph{¿Este objeto de qué tipo es?}

Los estudiantes necesitan entender la diferencia entre una variable y un conjunto de datos, además de que existen  variables (por ejemplo: \code{factor} para categórica, \code{numeric} para datos numéricos). Los instructores y los alumnos avanzados usualmente van a querer saber sobre los objetos de tipo \code{vector} y \code{list}.

\end{itemize}
De más detalles en cursos de niveles más avanzados.

Los estudiantes de niveles avanzados deberían aprender más sobre las funciones definidas por el usuario y las estructuras de control del lenguaje, como los loops y los condicionales. No es necesario saber tanto del lenguaje para estudiantes en cursos introductorios.

\item ``Menos vólumen, más creatividad"  [Mike McCarthy, entrenador, Green Bay Packers]

\Note{Esta es una de las motivaciones primarias detrás de nuestro paquete, \pkg{mosaic}, el cual busca hacer las cosas más simples y más similares; de esta forma los estudiantes pueden fácilmente volverse usuarios de R creativos e independientes. Incluso si usted decide no optar por hacer las cosas exactamente como las recomendamos, utilice el "Menos volumen, más creatividad" como guía.
.}

Use frecuentemente pocos métodos y los estudiantes van a aprender a usarlos bien, flexiblemente e incluso creativamente. 
Enfóquese en una cantidad pequeña de tipos de datos: numéricos, vectores, cadenas de signos y "dataframes". Elija funciones que empleen estructuras y estilos similares, para aumentar la habilidad de los estudiantes de transferir conocimiento de una situación a otra.
%\authNote{Add pointer here to more details? ---rjp}

%Not everything needs to be introduced from first principles.  For
%instance, categorical variables are easily enough understood by
%putting together simple concepts about character strings and vectors.

\item
Encuentre una forma de tener computadores disponibles para exámenes.

Esto hace que el examen vaya de acuerdo al resto del curso y motiva a los estudiantes a aprender \R. Esto también cambia lo que se puede preguntar en los exámenes.

Uno de nosotros hizo esto primero por la petición de un estudiante de un curso de estadística introductoria que pidió utilizar la computadora durante el examen " \emph{puesto que así hacía toda la tarea}". Ahora, él hace a sus estudiantes traer las laptops para los exámenes. Otro de nosotros utiliza los componentes de en clase (sin computadora) y fuera de clase (con computadora) para la evaluación
\item
Piense nuevamente su curso.

Si usted siempre ha enseñado sin computadores, o con relativamente poco uso de estos en el pasado, tal vez sea necesario que lo piense nuevamente. Con la extensión computacional, algunas cosas desaparecen del curso
\begin{itemize}
\item
Usar tablas estadísticas.   

\Note{Uno de los principales usos de la calculadora en los exámenes de AP Statistics es el cálculo de valores p y sus cuantilos relacionados.}
¿Alguien todavía consulta tablas para los valores de seno o $\log$ Todos nos hemos negado al uso de tabulaciones de valores críticos de una distribución (nosotros no lo usamos en nuestro trabajo profesional. ¿Por qué entonces es necesario enseñárselo a estudiantes?)

\item
Fórmulas de cálculo.

Reemplácelas con computación. Enseñe solo las fórmulas más intuitivas. Enfóquese en como llevan a la intuición y el entendimiento, \emph{no} el cálculo 

\item
(Casi) todos los cálculos a mano.

\end{itemize}

Al mismo tiempo, otras cosas se volvieron posibles que no eran posibles antes:
\begin{itemize}
\item
Conjuntos de datos grandes 
\item
Gráficos agradables 
\item
Simulaciones y métodos basados en la aleatorización y remuestreo. 
\item
Cálculos rápidos 
\item
Centralización en conceptos, en lugar de cálculos
\end{itemize}
Haga a sus estudiantes pensar que la computadores es parte de cómo ahora se hace estadística, en lugar de solamente un complemento.   

\item 
Mantenga el mensaje lo más simple posible y mantenga los comandos de la manera más simple   
\BlankNote[-1cm]{Es importante 
no empezar cosas muy complicadas de manera apresurada. En un inicio, es mejor utilizar los ajustes en predeterminado y centrarse en las ideas principales. Más tarde, se puede introducir opciones más finas conforme los estudiantes se sienten a gusto con las cosas simples (y usualmente están pidiendo más)}

Particularmente cuando esté haciendo gráficos, tenga cuidado de distraer a los estudiantes con detalles complejos de embellecimiento de publicaciones. Si el predeterminado es lo suficientemente bueno, déjelo así.

\item
Anticipe a estudiantes con problemas con la computadora, pero sea confiado de que usted los guiará por el camino correcto. 

Algunos estudiantes entienden R muy fácil. En todos los cursos habrá estudiantes que tendrán problemas. Para ayudarlos, enfóquese en diagnosticar lo que ellos no saben y cómo ayudarlos a solucionarlo 

La experiencia nos dice que la computadora es un chivo expiatorio de otras cosas que el estudiante no entiende. Como la computadora da respuestas inmediatas, revela estos malos entendidos. Por ejemplo, si los estudiantes están confundidos sobre la distinción de variable, estadística y unidades observaciones, va tener un rato complicado para brindarle la información correcta a una función de gráficos. Los estudiantes pueden culpar a R, pero eso no es el componente primario de la dificultad. Si tiene la capacidad de diagnosticar el verdadero problema, va mejorar el entendimiento de la estadística y arreglar dificultades con \R\ simultáneamente.
\TeachingTip[-2cm]{Cuando introduzca el código de \R\ a los estudiantes, enfatice las siguientes preguntas: \emph{¿Qué quiere que \R\ haga por usted?} y \emph{¿Qué información debe proveerle a \R\ para que logre hacer eso?} La primera pregunta generalmente determina la función que se va utilizar. La segunda determina los elementos de entrada que necesita la función.}%
%\authNote{Nick wanted more examples than this.}%
%\authNote{As per Nick's comment: Add pointer to examples? --rjp}%

Incluso estudiantes con un entendimiento sólido de conceptos estadísticos se van a encontrar con errores de \R\ que no pueden depurar.
\TeachingTip{Dígale a sus estudiantes que copien y pegue mensajes de error en un email en lugar de describirlos vagamente. Es un gran salvador de 
tiempo.}
Dígales a los estudiantes que copien y peguen los mensajes de error en un email cuando tienen problemas. Cuando les conteste, explíquele como el mensaje de error le ayudó a diagnosticar su problema y ayúdelo a generalizarlo para solucionar otras situaciones. Vea el capítulo~\ref{chap:RForInstructors} para algunos de los mensajes de error más comunes y lo que podrían indicar.
\end{enumerate}

\section{Tácticas}

\marginnote{\emph{Los estudiantes deben aprender a ver antes de ver para aprender}} % -- R. Pruim


\begin{enumerate}

\item
Introduzca los gráficos tempranamente


Introduzca gráficos de forma muy pronta, para que los estudiantes vean como pueden conseguir salidas impresionantes de comandos simples. Intente eliminar expectativas anteriores de que hay una ``curva empinada de conocimiento." 

Acepte los predeterminados -- no se preocupe por la belleza (los ejes, tamaños de la clase del histograma, colores) demasiado pronto. Déjelos sentirse cómodos con los comandos de gráficos básicos y después juegue (asegúrese de que se siente como jugar) haciendo las cosas más finas.

\marginnote{Para mantener este consejo, la mayoría de los ejemplos en este libro caen en el área del análisis de datos exploratorio. La organización de esto se eligió para desarrollar gradualmente un entendimiento de \R. Vea el volumen acompañante, \emph{Una guía para estudiantes de \R} para un recorrido de comandos utilizados en los primeros dos cursos de un pregrado de estadística. El volumen acompañante está organizado por tipos de análisis de datos y supone cierta familiaridad con el lenguaje \R.}

Tenga en mente que sólo porque los gráficos son fáciles de generar en la computadora no significa que los estudiantes sepan cómo leer los gráficos. Use ejemplos que ayuden a los estudiantes a generar buenos hábitos de visualización de datos.

\item Introduzca el muestreo y la aleatorización prontamente .

Puesto que el muestreo dirige una buena porción de la lógica estadística, introduzca la idea de las muestras aleatorias tempranamente y haga a los estudiantes construir sus propias muestras aleatorias. Este fenómeno de las distribuciones muestrales puede ser introducido de forma intuitiva, ajustándolo como un tema para discusión tardía y análisis.

\end{enumerate}



\chapter{Iniciando con RStudio}
\label{chap:RStudio}
<<echo=FALSE, include=FALSE>>=
knitr::opts_chunk$set( fig.path="figures/RStudio-" ) 
@

\RStudio\ es un entorno integrado de desarrollo (IDE por sus siglas en inglés) para \R\ que proporciona una alternativa de interface de \R, que tiene algunas ventajas sobre la interfaz predeterminada de \R.

\begin{itemize}

	\item 
	RStudio es ejecutable en máquinas Mac, PC o Linux y brinda una interfaz simplificada que se ve y se siente \emph{idéntico en todas ellas}

  La interfaz predeterminada de R es un poco diferente en las distintas plataformas. Esto es un
  distractor para los estudiantes y agrega una responsabilidad extra de conocimiento al instructor.
	\item
		\RStudio\ puede ejecutarse desde un navegador web

		\Note{Usar \RStudio\ en un navegador es como Facebook para estadística. Cada vez que el usuario
		vuelve, la sesión previa es restaurada y puede continuar el trabajo donde lo dejó. Los usuarios
		pueden iniciar sesión desde cualquier dispositivo con acceso a internet.}%
		Además de la versión para escritorio, RStudio puede ser utilizado y configurado como una
		aplicación en un servidor al que se tiene acceso vía internet. La instlación es sencilla para 
		cualquiera que sepa utilizar un sistema Linux. Una vez que el servidor se haya ajustado en su
		institución, los estudiantes puede empezar a usar \RStudio\ simplemente abriendo el sitio web
		e iniciando sesión. No es necesaria ninguna instalación adicional.

		La interfaz web es prácticamente idéntica a la versión de escritorio.% 
		\Caution{La versión de escritorio y la versión del servidor de RStudio son tan similares que si
		las ejecuta al mismo tiempo, tendrá que prestar mucha atención y asegurarse de que esté trabajan
		o en la que tenía intención de trabajar}
		Como con otros servicios web, el usuario debe hacer un inicio de sesión para acceder a su
		cuenta. Si los estudiantes cierran sesión y abren sesión después, incluso en una máquina
		diferente, la sesión es restaurada y pueden continuar sus análisis justo donde los dejaron. Con
		un poco de ajustes avanzados, los instructores pueden salvar el registro de su utilización de \R\
		en clase y pueden cargar estos archivos de registro en su propio entorno.%
	\item
		\RStudio\ brinda apoyo para la investigación reproducible. 

		\RStudio facilita incluir texto, análisis estadístico (código de R y 
		salidas de R), y gráficos, todo en un mismo documento.
		El sistema de RMarkdown proporciona una adición en el lenguaje 
		y produce documentos en HTML. Elsistema knitr/LaTeX permite a 
		los usuarios combinar \R y \LaTeX en el mismo documento. La recompensa por 
		aprender este sistema más complicado es un control más fino sobre el formato 
		del documento de salida. Dependiendo del nivel del curso, los estudiantes 
		pueden usar esto para tareas y proyectos. 
		
		 %\authNote{NH (via rjp): Add some pointers to more information?}
		 \Note{Para usar Markdown o \pkg{knitr}/\LaTeX se requiere que el paquete \pkg{knitr} 
		 esté instalado en su sistema.}
		 
		 \RStudio\ provee una interfaz funcional de gráficos para el usuario. RStudio 
		 no es un GUI para R, pero este sí brinda una GUI que simplifica cosas como 
		 instalar y actualizar los paquetes; monitorear, guardar y cargar entornos; 
		 importar y exportar datos; navegar y exportar gráficos; y navegar por archivos 
		 y documentación.

	 \item
		\RStudio\ ofrece una opción integrada para editar y ejecutar código de \R\, y documentos
		
	 \item
		 \RStudio\ provee una interfaz funcional de gráficos para el usuario.

		 \RStudio\ no es un GUI para \R, pero este sí brinda una GUI que simplifica cosas
		 como instalar y actualizar los paquetes; monitorear, guardar y cargar entornos; 
		 importar y exportar datos; navegar y exportar gráficos; y navegar por archivos 
		 y documentación.


	 \item
		 \RStudio\ permite acceso al paquete \pkg{manipulate}. 
		 
		 El paquete \pkg{manipulate} ofrece una forma fácil de crear aplicaciones gráficas 
		 que sean interactivas, fáciles y rápidas
\end{itemize}

Realmente se puede usar R sin RStudio, RStudio hace una cantidad considerable de cosas más sencillas, recomendamos vigorosamente la utilización de RStudio. Además puesto que RStudio está en desarrollo activo, tenemos la expectativa de más características útiles en el futuro.

%\begin{quote}
%\emph{This is a lightly modified version of a handout RJP used with his 
%Intro Stats students Spring 2011.  Aside from the occasional comment to
%instructors, this chapter could be used essentially as is with students.}
%\end{quote}


\section{Ajustando R y RStudio} 

RStudio puede ser obtenido en \url{http://cran.r-project.org/}. La descarga y la instalación están dirigidas a dispositivos Mac, PC o Linux. RStudio está disponible en \url{http://www.rstudio.org/}. RStudio puede ser instalado como una aplicación de escritorio o una aplicación de servidor.

\subsection{RStudio en la nube}
Nosotros primariamente usamos una versión en línea de \RStudio. \RStudio\ es una interfaz innovadora y poderosa de \R que se ejecuta en un navegador web o en el dispositivo local. Ejecutarlo en el navegador web tiene la ventaja de que no se tiene que instalar o configurar nada. Sólo se debe iniciar sesión y listo. Entonces, RStudio va "recordar" lo que usted estaba haciendo cada vez que inicie sesión (incluso en dispositivos diferentes) lo puede retomar justo donde lo dejó. Esto es "R en la nube" y funciona un poco como GoogleDocs o Facebook para R.

Es posible que el administrador de su sistema necesite ajustar la instalación de \RStudio\ para su institución, pero le aseguramos que este proceso es sumamente sencillo y facilitará a los estudiantes y la facultad el uso.

\subsection{RStudio en su computadora}
Hay también una versión autónoma del entorno de RStudio que se puede instalar en su computadora.  
Esta puede ser descargada de \url{http://www.rstudio.org/}. Se supone que usted tiene una versión de R en su computadora (observe más abajo instrucciones para descargarlo de CRAN). Incluso si sus estudiantes están primaria o exclusivamente utilizando en la edición del web de RStudio, los instructores deberían tener una manta de seguridad de la versión que no requiere acceso a internet. Sea precavido, las dos versiones se ven tan similares que ocasionalmente se puede encontrar a usted mismo trabajando en una cuando tenía la intención de trabajar en la otra.

\subsection{Consiguiendo R de CRAN}
\label{sec:CRAN}

CRAN es el Comprehensive R Archive Network (\url{http://cran.r-project.org/}). Puede descargar versiones gratuitas de R para pc, Mac y Linux de CRAN. (Si usa la versión autónoma de RStudio, necesita instalar \R\ de esta forma primero). Todas las instrucciones para instalarlo están en CRAN. Sólo siga las instrucciones apropiadas para su plataforma.

\subsection{Ejecutar RStudio por la primera vez}
Una vez que haya iniciado la versión de escritorio o haya iniciado sesión en el servidor de RStudio, usted verá algo como lo siguiente:

\begin{center}
\includegraphics[width=1.0\textwidth]{images/RStudio-bigview}
\end{center}

Observe como \RStudio\ divide su universo en cuatro paneles. Algunos paneles después son subdivididos en múltiples viñetas. Qué viñetas aparecen y cuales paneles aparecen puede ser personalizado por el usuario.
\TeachingTip{Nosotros encontramos conveniente poner la consola en la parte superior derecha en lugar de en su ubicación predeterminada (parte superior izquierda) así los estudiantes pueden ver mejor cuando proyectamos \R{} en clase}

\section{Usando la consola de R como calculadora}
R puede hacer mucho más que una simple calculadora, y vamos a introducir estas características en su debido tiempo. Pero representar cálculos simples en R es una buena forma de comenzar a aprender las características de RStudio

Los comandos ingresados en la viñeta de \tab{console} son inmediatamente ejecutados por \R. Una buena forma de familiarizarse con la consola es hacer cálculos simples. Intente escribir los siguientes comandos en el panel de la consola.

<<arithmetic>>=
5 + 3
15.3 * 23.4
sqrt(16)              # square root
@


Este último ejemplo demuestra como las funciones son llamadas dentro de \R\ como también el uso de comentarios. Los comentarios son anticipados por el símbolo \verb!#!. Los comentarios pueden ser de mucha ayuda cuando se escriben scripts con múltiples comandos o para anotar código de ejemplo para sus estudiantes.

Usted puede guardar valores en variables nombradas para reutilización posterior.


<<rs-variables1a,tidy=FALSE>>=
product = 15.3 * 23.4   # save result
product                 # display the result
product <- 15.3 * 23.4  # <- instead of =
product                     
@
\TeachingTip[-2cm]{Probablemente es mejor establecer el uso de uno u otro operador de 
asignación en lugar de estar cambiándolo. Personalmente preferimos el operador de la 
flecha, porque representa visualmente lo que está pasando en la asignación además porque 
deja clara la distinción entre el operador de asignación, el uso de \code{=}  en este caso 
es para dar valores a los argumentos de funciones, y el uso de \code{==} para probar
la igualdad.}%

Una vez que las variables son definidas, pueden ser referenciadas en otras operaciones 
y funciones.



<<rs-variables2,tidy=FALSE>>=
0.5 * product        # half of the product
log(product)         # (natural) log of the product
log10(product)       # base 10 log of the product
log2(product)        # base 2 log of the product
log(product, base=2) # another way for base 2 log
@
\authNote{can we come up with a better (e.g. less mathematical) example?}

El punto y coma puede ser utilizado para ubicar comandos múltiples en una sola línea. Un uso frecuente de esto puede ser para salvar y después imprimir un valor, en una sola línea:

<<rs-variables-semi,tidy=FALSE>>=
# store and show result
product <- 15.3 * 23.4; product  
@



\section{Trabajando con archivos}

\subsection{Archivos \R\ script}
Como alternativa, los comandos de \R\ pueden ser almacenados en un archivo. \RStudio\ ofrece un editor integrado para editar este tipo de documentos y facilita ejecutar algunos o todos los comandos. Para crear un archivo, seleccione en el menú de \RStudio: \tab{File}, después \tab{New File}, después \tab{R Script}. Una ventana del editor de archivos se va abrir en el panel de \tab{Source}. El código de \R\ puede ser escrito ahí, y botones e ítems de menú son provistos para correr todo el código (llamado abastecer el documento) o ejecutar el código en una sola línea o en una sección seleccionada del documento.

\subsection{RMarkdown, y knitr/\LaTeX}
Una tercera alternativa es tomar ventaja del apoyo que brinda RStudio para la investigación reproducible. Si usted ya conoce \LaTeX, va a querer investigar las capacidades de \pkg{knitr}/\LaTeX. Para aquellos que no conocen \LaTeX todavía, el sistema de RMarkdown es más sencillo y proporciona una entrada fácil en el mundo de los métodos de la investigación reproducible. Además brinda una buena estructura para que los estudiantes creen sus tareas y reportes que incluyen texto, código de \R, salidas de \R y gráficos.

Para crear un nuevo archivo de RMarkdown, seleccione la pestaña de \tab{File}, después \tab{New File}, después \tab{RMarkdown}.El archivo va ser abierto con un pequeño documento de plantilla que ilustra la especificación que tiene el lenguaje. Si puede hace click en \tab{From template}, antes de crear el documento, se le dará una lista de documentos de plantilla disponibles en paquetes. Si el paquete \pkg{mosaic} está cargado, esta lista va incluir plantillas que se aseguran que el paquete \pkg{mosaic} este cargado y cambie los tamaños predeterminados para los gráficos, para que sean un poco más pequeños que los genericos de RStudio. La versión fancy muestra muchas de las características de RMarkdown. (El sitio de \RStudio\ incluye un tutorial extensivo de como usar RMarkdown que demuestra un rango de características más amplio). La plantilla plain es diseñada para crear rapidamente nuevos documentos empezando casi en blanco.

El proceso de ejecutar código de \R{} y combinar texto, código de \R{}, salidas, y gráficos es un mismo archivo se llama ``knitting".
Presione en \tab{knit} para convertir el documento RMarkdown en un archivo HTML, PDF, o Word.


%
Es importante recordar que contrario a los scripts de R que son ejecutados en la consola y tiene acceso al entorno de la consola, los archivos de RMarkdown y knitr/LaTeX no tienen acceso al entorno de la consola. Esto es una buena característica puesto que obliga a los archivos a ser auto-contenidos, lo cual los hace transferibles y respeta las buenas prácticas de la investigación reproducible. Pero en el caso de los principiantes, especialmente si adoptan una estrategia de probar cosas en la consola, y copiar y pegar código de la consola en su documento, crean archivos que son incompletos y por esto no compilan correctamente.

Una buena estrategia para que los estudiantes usen RMarkdown es proporcionarles un documento de ejmemplo que incluya la plantilla que usted desee que utilicen,
cargue cualquier paquete de \R\ que necesiten, ajuste
las opciones del paquete \pkg{knitr} u opciones de \R\ de la forma que usted las prefire,
y tiene lugares para poner el trabajo donde usted quiere que lo realicen.



\section{Los otros paneles y viñetas}

\subsection{La viñeta de historial (History)}

Como los comandos son ingresados en la consola, así aparecen en la viñeta de \tab{History}. Estas "historias" o historiales pueden ser guardados y cargados, hay una opción de búsqueda para encontrar comandos previos, y líneas individuales previas o secciones pueden ser transferidas de vuelta a la consola. Mantener la viñeta de History abierta le permite ir atrás y ver varios comandos anteriores. Esto puede ser especialmente útil cuando ciertos comandos producen una salida grande entonces la pantalla se mueve hacia abajo rápidamente.

Una alternativa es producir documentos RMarkdown con instrucciones en el código.

\subsection{Comunicación entre viñetas}

\RStudio\ brinda varias formas de mover código de \R entre las viñetas. Presionar el botón de \tab{Run} en el panel de edición para un script de \R o \pkg{RMarkdown} o algún otro documento va copiar líneas de código en la consola y ejecutarlas.
\subsection{La viñeta de archivos}
La viñeta de archivos provee un manejador de datos simples. En esta se puede navegar de forma amigable y puede ser utilizada para abrir, renombrar y borrar archivos. En la versión de navegador web de \RStudio, la pestaña de archivos también ofrece una utilidad para subir los archivos de la máquina local al servidor. En archivos de \pkg{RMarkdown} y \pkg{knitr} también se puede ejecutar código en algún "chunk" del archivo o en todos los "chunks" del archivo. Cada una de estas características simplifica el intentar escribir código "en vivo" mientras se crea un documento que deja un historial del código.

En la dirección inversa, el código del historial puede ser copiado de nuevo en la consola para ejecutarlo de nuevo (después de un poco de edición) o en una de las viñetas de edición, para la inclusión en un archivo.



\subsection{The Help Tab}
La viñeta de ayuda (Help) es donde RStudio despliega los archivos de ayuda de R. Se puede abrir un archivo de ayuda usando el operador \texttt{?} en la consola. 

Por ejemplo, el siguiente comando va mostrarnos el archivo de ayuda para la función de logaritmo.
<<eval=FALSE, tidy=FALSE>>=
?log
@

\subsection{La pestaña de Entorno (Environment)}
La viñeta de entorno (\tab{Environment}) muestra los objetos disponibles para la consola. Estos están subdivididos en datos, valores (no son objetos de tipo conjunto de datos, ni objetos de tipo función) y funciones.

El ícono de la escoba puede ser utilizado para remover todos los objetos del entorno, y es bueno hacer esto de vez en cuando, especialmente cuando se está ejecutando RStudio en el servidor o si decide salvar el entorno cuando cierra \RStudio, puesto que en estos casos los objetos se pueden quedar en el entorno indefinidamente.

\subsection{La viñeta de gráficos}

\marginnote{Si no ha estado ingresando los comandos que mostramos anteriormente, se le recomienda devolverse e ingresarlos.}

Los gráficos creados en la consola son desplegados en la viñeta de gráficos (\tab{Plots}). Por ejemplo, los siguientes comandos despliegan el número de nacimientos en Estados Unidos cada día en 1978.
<<fig.width = 4.5, fig=TRUE>>=
#Esto hace los gráficos lattice disponibles
require(mosaic)       
xyplot( births ~ dayofyear, data=Births78)
@
\noindent
En la viñeta de gráficos, se puede navegar a gráficos anteriores y también exportar gráficos en varios formatos, después de interactivamente manipular las dimensiones.


% this fixes bad spacing -- but I don't know why the spacing was bad
\bigskip
\subsection{La viñeta de paquetes}

Mucha de la funcionalidad de \R\ está localizada en paquetes, muchos de los cuales se pueden obtener de la casa matriz llamada CRAN (Comprehensive R Archive Network). 

La viñeta de paquetes (\tab{packages}) facilita instalar y cargar paquetes. También le permite buscar paquetes que han sido actualizados desde que usted los instaló.


%\section{Exercises}

%For these problems, create a single Word document containing all of your work.

%\shipoutProblems



\chapter{Usando R tempranamente en cursos}
<<echo=FALSE, include=FALSE>>=
opts_chunk$set( fig.path="figures/EarlyR-" ) 
@
\label{chap:EarlyR}
Este capítulo incluye algunas de nuestras actividades favoritas para iniciar los cursos. Estas actividades simultáneamente les dan a los estudiantes su primer vistazo a R y a la introducción de algunos temas importantes del curso. Si lo vemos de esta forma, no es necesario que los estudiantes entiendan detalles del código de R. En lugar de eso, los centramos en las preguntas y como los resultados presentados les dan un "chispazo" de cómo responder estas preguntas.

\section{Monedas y tasas: La dama y la degustación de té}
\label{sec:lady-tasting-tea}

\marginnote{Esta sección es una versión levemente modificada de un folleto que uno de los autores le da a sus estudiantes de introducción a la estadística en el Día 1 \underline{después} al final de la actividad para generar una discusión en la clase}

Hay un famoso relato sobre una dama que afirmaba que el té tenía un sabor diferente dependiendo de si la leche era se la agregaba té o si se le agregaba el té a la leche. El relato es famosos por el escenario en que ella hizo esta afirmación. Ella estaba en una fiesta en Cambridge, Inglaterra, en los años 1920s. A la fiesta también se presentaron varios catedráticos universitarios y sus esposas. Los científicos que asistieron se burlaron de la afirmación. ¿Qué, después de todo, era la diferencia?

\myindex{Fisher, R. A.}%
Todos los científicos, excepto uno. En lugar de simplemente ignorar la afirmación de la dama, propuso que decidieran cómo se debía hacer una prueba de la afirmación. El tono de la conversación cambió después de la sugerencia del científico, y este mismo empezó a discutir como la afirmación debía probarse. En unos minutos, tasas de té con leche fueron preparadas y presentadas a la mujer para que las probara.

%\iffalse
%Let's take this simple example as a prototype for a statistical study.
%What steps are involved?  
%begin{enumerate}
 % \item Determine the question of interest.
%
%	Just what is it we want to know?  It may take some effort to 
%	make a vague idea precise.  The precise questions may not exactly
%	correspond to our vague questions, and the very exercise of 
%	stating the question precisely may modify our question.  Sometimes
%	we cannot come up with any way to answer the question we really want
%	to answer, so we have to live with some other question that is 
%	not exactly what we wanted but is something we can study and will
%	(we hope) give us some information about our original question.
%
%	In our example this question seems fairly easy to state:
%	Can the lady tell the difference between the two tea preparations?
%	But we need to refine this question.  For example, are we 
%	asking if she \emph{always} correctly identifies cups of tea
%	or merely if she does better than we could do ourselves (by 
%	guessing)?  

 % \item 
	%Determine the \term{population}. 
	%\myindex{population}%

	%Just who or what do we want to know about?  Are we only interested in
	%this one woman or women in general or only women who claim to
	%be able to distinguish tea preparations?

  %\item
	%Select \term{measurements}.

	%We are going to need some data.  
	%We get our data by making some measurements.
	%These might be physical measurements with some device (like a ruler
	%or a scale).
	%But there are other sorts of measurements too, 
	%like the answer to a question on a form.
	%Sometimes it is tricky to figure out just what to measure.
	%(How do we measure happiness or intelligence, for example?)
	%Just how we do our measuring will have important consequences 
	%for the subsequent statistical analysis.
	%The recorded values of these measurements are called
	%\term{variables} (because the values vary from one individual to another).

	%In our example, a measurement may consist of recording for a given
	%cup of tea whether the woman's claim is correct or incorrect.
	%it is milk-into-tea or tea-into-milk.

  %\item
	%Determine the \term{sample}.
	%\myindex{sample}%

	%Usually we cannot measure every individual in our population; we have 
	%to select some to measure.  
	%But how many and which ones?  
	%These are important questions that must be answered.
	%Generally speaking, bigger is better, but it is also more expensive.
	%Moreover, no size is large enough if the sample is selected inappropriately.

	%Suppose we gave the lady one cup of tea.  If she correctly identifies
	%the mixing procedure, will we be convinced of her claim?  She might just
	%be guessing; so we should probably have her taste more than one 
	%cup.  Will we be convinced if she correctly identifies $5$ cups? $10$ cups?
	%$50$ cups?

	%What if she makes a mistake?  If we present her with $10$ cups and she
	%correctly identifies $9$ of the $10$, what will we conclude?  
	%\authNote{added A success rate of -- 2010-10-23}%
	%A success rate of $90$\% is, it seems,
	%much better than just guessing, and anyone can make a mistake now and then.
	%But what if she correctly identifies $8$ out of $10$? $80$ out of $100$?
	
	%And how should we prepare the cups?  Should we make $5$ each way?  
	%\authNote{Left it as "and how" -- 2010-10-23}%
	%Does it matter if we tell the woman that there are $5$ prepared 
	%each way?
	%Should we flip a coin to decide even if that means we might end 
	%up with $3$ prepared one way and $7$ the other way?  
	%Do any of these differences matter?

  %\item
	%Make and record the measurements.

	%Once we have the design figured out, we have to do the legwork of 
	%data collection.  This can be a time-consuming and tedious process.
	%In the case of the lady tasting tea, the scientists decided to 
	%present her with ten cups of tea which were quickly prepared.
	%A study of public opinion may require many thousands of phone calls or 
	%personal interviews.
	%In a laboratory setting, each measurement might be the result 
	%{of a carefully performed laboratory experiment.

  %\item Organize the data.

	%Once the data have been collected, it is often necessary or useful
	%to organize them.  Data are typically stored in spreadsheets or 
	%in other formats that are convenient for processing with 
	%statistical packages.  Very large data sets are often stored in 
	%databases.  
	
	%Part of the organization of the data may involve producing graphical and
	%numerical summaries of the data.  These summaries may give us initial
	%insights into our questions or help us detect errors that may have occurred
	%to this point.

  %\item Draw conclusions from data.

	%Once the data have been collected, organized, and analyzed, we need
	%to reach a conclusion.  
	%Do we believe the woman's claim?  
	%Or do we think she is merely guessing?  How sure are we that this
	%conclusion is correct?

%	In Parts~\ref{part:inf1}--\ref{part:inf2} 
	%Eventually we will
	%learn a number of important and frequently used methods for 
	%drawing inferences from data.  More importantly, we will learn
	%the basic framework used for such procedures so that it should 
	%become easier and easier to learn new procedures as we become 
	%familiar with the framework.
	
	%How strongly do we believe it?  

  %\item Produce a report.

	%	Typically the results of a statistical study are reported in 
	%	some manner.  This may be as a refereed article in an academic 
	%	journal, as an internal report to a company, or as a solution
	%	to a problem on a homework assignment.  These reports may themselves
	%	be further distilled into press releases, newspaper articles,
	%	advertisements, and the like.  The mark of a good report
	%	is that it provides the essential information about each 
	%	of the steps of the study.

	%	As we go along, we will learn some of the standard terminology and
	%	procedures that you are likely to see in basic statistical reports and 
	%	will gain a framework for learning more.  
%\end{enumerate}

%\fi

En este punto, usted podría estar preguntándose quién fue el científico innovador y cuáles fueron los resultados del experimento.
\myindex{Fisher, R. A.}%
El científico fue R.A Fisher, quien primeramente describió la situación como un ejemplo pedagógico en su libro de metodología \cite{Fisher:1925:Methods} estadística en 1925.
%\authNote{Can we move to a non-CS style for references?  It would be more approachable
%for this audience I suspect.}
Fisher desarrolló métodos estadísticos que son parte de los más importantes y mayormente utilizados a la fecha, y la mayoría de sus aplicaciones son biológicas.
\nocite{Fisher:1970:Methods}%

Usted podría también tener curiosidad sobre cómo el experimento terminó. 
¿Cuántas copas de té fueron preparadas? 
¿Cuántas identificó la dama correctamente? ¿Cuál fue la conclusión?

Fisher nunca lo dice. En su libro, él está interesado en el método, no en los resultados en particular. Sin embargo, podemos usar estos ajustes para introducir algunas claves de estadística.

Supongamos que decidimos probar a la dama con diez tazas de té. Vamos a lanzar una moneda para decidir de qué forma preparar las tasas. Si la lanzamos y un escudo, tenemos que poner la leche primero; si es corona, ponemos primero el té. Después presentamos las diez tasas a la dama y le pedimos que nos diga cuales fueron hechas de qué manera.

Es sencillo darle la puntuación (9 de 10, 7 de 10, o lo que sea que sucede)  
\TeachingTip{El puntaje es un ajuste para la idea de una prueba estadística, pero no es necesario introducir esa terminología en el día 1}
Es un poco más confuso saber qué hacer con el puntaje. 
Incluso si ella está adivinando y no tiene ni idea, puede tener suerte y tener algunas correctas -- incluso todas las 10. ¿Pero, qué tan verosímil es eso?

Intentemos un experimento. Yo lanzo 10 monedas. Usted adivina cuales son escudos y cuales coronas, y vemos cómo lo hace. 
\TeachingTip{Haga que cada estudiante haga su suposición escribiendo una secuencia de 10 escudos y 10 coronas mientras usted lanza las 10 monedas detrás de una barrera para que los estudiantes no puedan ver los resultados. }

\bigskip
\bigskip
%$\vdots$

Comparando con los compañeros de clases, vamos a ver sin duda que algunos adivinaron mejor que otros.

Ahora suponga que la dama dice 9 de 10 correctamente Esto no es perfecto, pero es mejor de lo esperado para alguien que estaba adivinando. Por otro lado, no es imposible acertar 9 de 10 adivinando. Entonces aquí está la gran idea de Fisher: Averigüemos que tan difícil es acertar 9 de 10 veces adivinando. Si no es tan díficil de hacer, entonces puede ser que eso haya ocurrido, entonces no deberíamos estar muy impresionados de la capacidad de degustar té de la mujer. Por otro lado, si es realmente inusual conseguir 9 de 10 aciertos adivinando, entonces tenemos evidencia que puede ser que nos diga algo.

¿Pero cómo nos damos cuenta de qué tan inusual es acertar 9 de 10 solamente adivinando? Ya aprenderemos otro método, pero por ahora sólo tiremos un montón de monedas y mantengamos un control de estas. Si ella está adivinando, podrá también estar tirando una moneda.

Entonces este es el plan. Vamos a lanzar 10 monedas. Vamos a llamar los escudos aciertos y las coronas fallos. Ahora vamos a tirar 10 monedas más, y 10 más, y 10 más y \dots Eso se volvería bastante tedioso. Afortunadamente las computadoras son buenas con las cosas tediosas, así que permitimos a la computadora tirarlas por nosotros.

La función \function{rflip} puede tirar una moneda

\Note[3cm]{Hay un cambio sutil aquí. Antes le preguntábamos a los estudiantes cuantas H's y cuantas T's acertaron de la moneda tirada. Ahora estamos usando H para simular los aciertos al adivinar y las T los desaciertos al adivinar. Esto hace simular más fácil.}

<<flip1coin>>=
require(mosaic)
rflip()
@

\noindent
O un número de monedas
<<flip10coins,cache=FALSE>>=
rflip(10)
@

Escribir \code{rflip(10)} muchas veces es casi tan tedioso como tirar las monedas. Pero no es tan difícil decirle a \R\ que haga \function{do()} una serie de veces.
\Note{Note que \function{do()} es inteligente sabiendo que información guardar. En lugar de guardar todo lo que individualmente da, sólo guarda el número de tiradas, el número de escudos y de coronas}%
<<flip2,cache=TRUE,message=FALSE,warning=FALSE>>=
do(3) * rflip(10)
@

\newpage
\noindent
Ahora hagamos que \R\ haga \function{do()} para nosotros 100000 veces y hagamos una tabla de resultados

<<seed123,echo=FALSE,results='hide'>>=
set.seed(123)
@

\TeachingTip[-1cm]{Siempre está la pregunta de cuantas simulaciones hacer. Este es un punto medio entre la velocidad y la precisión. Para cosas simples, uno puede fácilmente ejecutar 100000 o más simulaciones en clase. Para cosas más complicadas (que pueden requerir ajustar un modelo y extraer información de cada iteración) puede ser que prefiera un número menor de iteraciones para demostraciones en clase

Cuando se cubra inferencia para una proporción, es buena idea usar estos métodos para revisar la pregunta de cuantas replicaciones son necesarias en ese contexto.}


<<lady-dolots,cache=TRUE>>=
# Guarde los resultados de 10000 damas simuladas
random.ladies <- do(10000) * rflip(10)
@

<<lady-table, tidy=FALSE>>=
tally(~heads, data=random.ladies)
# También podemos desplegar una 
#tabla usando porcentajes
tally(~heads, data=random.ladies, format="prop")  
@

Podemos desplegar esta tabla gráficamente con un gráfico llamado histograma y con clases de ancho 1.
\Note{El paquete \pkg{mosaic} le agrega algunas características adicionales a la función \function{histogram()}. En particular, los argumentos de ancho del intervalo y del centro, que hace más fácil el control de las clases; esto sólo está disponible si está usando el paquete \pkg{mosaic}.}

<<lady-hist,fig.width=3,fig.height=1.6>>=
histogram(~ heads, data=random.ladies, width=1)  
@

Usted puede estar sorprendido de ver que el número correcto de aciertos igual a 5 (la mitad de los 10 intentos) sucede solo 25\% de las veces. Pero la mayoría de los resultados están cerca de 5 correctas. Por ejemplo 67\% de los resultados son 4, 5 o 6. Aproximadamente 90\% de los resultados están entre 3 y 7 (incluyéndolo). Pero tener 8 correctas es inusual, y 9 o 10 todavía más inusual.

¿Entonces, qué concluimos? Es posible que la dama tuviera 9 de 10 correctas adivinando, pero no es verosímil (sólo paso 1.2\% de nuestras simulaciones). Entonces una de dos cosas es verdad:
\begin{itemize}
\item
La dama es inusualmente suertuda, o  
\item
La dama no está adivinando.
\end{itemize}

¡Aunque Fisher no dice como resultó el experimento, otros dicen que la dama identificó correctamente las 10 tasas!
\cite{salsburg}


\newthought{Un diseño diferente}

Suponga que en lugar de lo anterior, vamos a preparar cinco copas de cada forma (y que la dama que las probará supiera esto) le damos cinco cartas que dicen "leche primero" y ella debe ponerlas junto a las tasas en las que la leche se sirvió primero. ¿Cómo este diseño cambia las cosas?

Podemos simular barajas de 10 cartas y sacar cinco de ellas.

\Note{El uso de \function{factor()} aquí permite a \R\ saber que los posibles valores son 'M' y 'T', incluso cuando uno o el otro aparezca en una muestra aleatoria.}
<<lady-five-cards>>=
cards <- 
  factor(c("M","M","M","M","M","T","T","T","T","T"))
tally(~deal(cards, 5))
@

<<lady-five,cache=TRUE>>=
results <- do(10000) * tally(~deal(cards, 5))
tally(~ M, data=results)
tally(~ M, data=results, format="prop")
tally(~ M, data=results, format="perc")
@

\section{Nacimientos por día}

\label{sec:Births78Intro}
El conjunto de datos \dataframe{Births78} contiene el número de nacimientos en Estados Unidos para cada día de 1978. 
\Note{El uso de la frase "depende de" es intencional. 
Más adelante vamos a enfatizar en como \code{y~x} puede ser interpretado como ``\code{y} depende de \code{x}"}
Un gráfico de dispersión de los nacimientos por día del año revela algunos patrones interesantes. Veamos como el número de nacimientos depende del día del año.

<<births1,out.width=".8\\textwidth",fig.width=5, fig=TRUE>>=
xyplot(births ~ dayofyear, data=Births78)
@
\TeachingTip[-2cm]{El gráfico puede también ser construido usando la variable \variable{date}. Para propósitos generales, este puede ser un mejor gráfico a construir, pero usar \variable{dayofyear} fuerza a los estudiantes a pensar más en lo que el eje x significa}

Cuando se les muestra esta imagen, los estudiantes deberían estar listos para describir los dos patrones en los datos; deberían notar que ambas bajadas y subidas en el curso del año y las dos "ondas paralelas". Hacer que los estudiantes conjeturen acerca de estos rápidamente revela si están interpretando correctamente un gráfico. 
\TeachingTip{Esto puede hacer una buena actividad de pensar y compartir. Haga que los estudiantes hagan explicaciones posibles, y que después discuta estas explicaciones con un compañero. Finalmente, haga a algunas parejas compartir sus explicaciones con toda la clase}
Many students will be able to come up with conjectures about the peaks and valleys, but they often struggle to correctly interpret the parallel waves.  Having them make conjectures about this will quickly reveal whether they are correctly interpreting the plot.

Una conjetura acerca del paralelismo de las ondas puede ser revisada usando los datos disponibles. Si desplegamos cada día de la semana con diferente símbolo o color, podemos ver que hay menor cantidad de nacimientos los fines de semana. Hay algunas excepciones que se pueden ver, los días libres o feriados.

\newpage

<<births2,echo=FALSE,results='hide'>>=
trellis.par.set(superpose.symbol=list(pch=16, alpha=.6, cex=.6))
@
\TeachingTip{Esta cantidad de excepciones es fácil de ver si "conectamos los puntos", vea sección 4.6.1}

<<births3,fig.width=5,fig.height=3.0,tidy=FALSE, fig=TRUE>>=
require(mosaicData)       # Carga los conjuntos de datos
xyplot(births ~ dayofyear, data=Births78, 
       groups=wday,
       auto.key=list(space="right")) 
@

Una discusión de este u otro conjunto de datos que pueden ser explorados mediante exposiciones gráficas estadísticas es una buena forma de demostrar "curiosidad estadística", para ilustrar el poder de R para crear gráficos, y para introducir la importancia de las co-variables en el análisis estadístico.
\marginnote[-3cm]{A la visualización la han llamado la "droga de entrada" a la estadística. Puede ser una gran forma de ingresar a los estudiantes en la estadística -- y lejos de sus calculadoras con graficadores}

%We'll return to this data set later to see ways it can be used for more formal analyses.
%\authNote{rjp: Restore comment about returning to this data only if we do return to it.}

\section{SAT y cofundación}
\label{sec:secconfound}
%\authNote{NH (or others) to finish this example.}

El conjunto de datos \dataframe{SAT} contiene información acerca de la relación entre los puntajes obtenidos en el SAT y las medidas de gasto educativo. Los estudiantes frecuentemente se sorprenden de ver que estados que gastan más en educación tienen peores resultados en los SAT.

\hfill\newpage

<<SAT1, fig=TRUE>>=
xyplot(sat ~ expend, data=SAT)
@

La implicación, que gastar menos puede dar mejor resultado es injustificado. Los gastos son confundidos con la proporción de estudiantes que toman el examen, y las notas son mayores en estados donde una menor cantidad de estudiantes hacen el examen.
<<out.width = ".47\\textwidth">>=
xyplot(expend ~ frac, data=SAT)
xyplot(sat ~ frac, data=SAT)
@

Es interesante ver el gráfico original si ubicamos a los estados en dos grupos dependiendo si tienen más o menos 40% de los estudiantes que hicieron el SAT
<<>>=
SAT <- mutate(SAT, 
        fracGroup = derivedFactor( 
          hi = (frac > 40), 
          lo = (frac <=40) ))
@

<<out.width = ".47\\textwidth", fig=TRUE>>=
xyplot(expend ~ frac, data=SAT)
xyplot( sat ~ expend | fracGroup , data=SAT, 
        type=c("p","r") )
xyplot( sat ~ expend, groups = fracGroup , data=SAT, 
        type=c("p","r") )
@

Este ejemplo puede usarse para advertirnos contra interpretar relaciones causales e ilustrar la importancia de considerar co-variables.

% fixing bad spacing at section break.
\bigskip
\section{Enfermedad de Wilts y los ácaros}
\label{sec:mites}

\emph{Este ejemplo muestra cómo construir inferencia estadística desde principios primarios}
%\authNote{NH wants to add reference and perhaps revise this example once more}%


Los investigadores sospechan que el ataque de una planta por otro organismo induce la resistencia al ataque subsecuente por un organismo diferente. Unas plantas de algodón en macetas individuales fueron aleatoriamente distribuidas en dos grupos: invadidas por arañas enanas y sin invasión. Después de dos semanas, las arañas fueron removidas responsablemente por un asistente de la investigación, y ambos grupos fueron tratados con Verticillium, un hongo que causa la enfermedad de Wilt. Los investigadores estaban esperando que los datos dieran luz para responder la siguiente pregunta:

\begin{center}
¿Hay una relación entre la plaga y la enfermedad de Wilt? 
\end{center}

The accompanying table shows a cross tabulation the number of plants that
developed symptoms of Wilt disease.
\newpage

<<eval=TRUE, message=FALSE, tidy=FALSE>>=
tally(outcome ~ treatment, data = Mites, margins = TRUE)
@

\noindent
Algunas preguntas para los estudiantes:
\begin{enumerate}
\setlength\itemsep{1mm}
  \item ¿Cuál piensa que es la variable predictora? ¿La variable respuesta?
  \item ¿Qué proporción de las plantas del estudio que tuvo el problema de arañas desarrolló enfermedad de Wilt?
  \item ¿Qué proporción de plantas en el estudio que tuvo el problema de arañas desarrolló enfermedad de Wilt?
  \item El riesgo relativo es el radio de los proporciones de riesgo. ¿Cuál es el riesgo relativo de desarrollar una enfermedad de Wilt, comparando aquellos que tuvieron arañas y los que no?
  \item ¿Si no hubiera asociación entre las arañas y la enfermedad de Wilt, cuál sería el riesgo relativo (en la población)? ¿Qué tan cerca está este riesgo relativo calculado de los datos de este valor?
%  \item After conditioning on the margins, how many degrees of freedom are there in this table?
  \item Sea $X$ el número de plantas en el grupo que no tuvo arañas que no desarrolló enfermedad de Wilt. ¿Cuáles son los posibles valores de $X$?
  \item Asumiendo una población con riesgo relativo 1, dele dos posibles valores a X que puedan ser más inusuales que los valores para estos datos
	  \saveenumi
\end{enumerate}

Las preguntas 6-7 pueden ser vistas usando cartas


%\begin{widestuff}
%\begin{boxedText}
%	\centerline{\textbf{Physical Simulation}}

%\begin{enumerate}
%  \item Select 47 cards from your deck: 26 red (mites!) and 21 black
%  \item Shuffle the cards well
%  \item Deal out 19 cards, these represent the 19 plants without Wilt disease.
%  \item Count the number of black cards among those 19.  What do these represent?
%  \item Repeat steps 2 --4, five times. 
%\end{enumerate}
%\end{boxedText}
%\end{widestuff}

%\iffalse
%\begin{center}
%\begin{tabular}{|c|c|c|c|c|c|}
%  \hline
%  $X_1$ & $X_2$ & $X_3$ & $X_4$ & $X_5$ & $X_6$ \\
%  \hline
%  \hspace{0.75in} & \hspace{0.75in} & \hspace{0.75in} & \hspace{0.75in} & \hspace{0.75in} & \hspace{0.75in} \\[5ex]
%  \hline
%\end{tabular}
%\end{center}

%\vspace{2in}

%\begin{center}
%\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
%  \hline
%  0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 \\
%\end{tabular}
%\end{center}
% 0      1      2      3      4      5      6      7      8      9      10      11     12      13     14    15     16     17     18     19  
% 
%\fi

Los estudiantes pueden juntar sus resultados al ponerlos en la 
pizarra al frente del salón. Después los estudiantes pueden procesar los resultados contestando las siguientes preguntas.
\begin{enumerate}
		\reuseenumi
    \setlength\itemsep{2mm}
  \item ¿Cuantas cartas negras esperamos (en promedio)?
  \item ¿Qué observamos?
  \item ¿Cómo resumimos estos resultados? ¿Cuál es la gran idea?
\end{enumerate}

Una vez que la simulación con cartas ha sido completada, podemos usar \R\ para hacer muchísimas más simulaciones rápido
%\hfill\newpage

\begin{widestuff}

\begin{boxedText}
	\centerline{\textbf{Computational Simulation}}

<<eval=TRUE,tidy=FALSE,warning=FALSE,message=FALSE, fig=TRUE>>=
tally(outcome ~ treatment, data=Mites)
X <- tally(outcome ~ treatment, data=Mites)[1,1]; X
nullDist <- do(1000) * 
  tally(outcome ~ shuffle(treatment), data=Mites)[1,1]
histogram(~ result, data=nullDist, width=1, 
          type="density", fit="normal", v=15) 
@

\end{boxedText}
\end{widestuff}

\hfill\newpage

<<echo=FALSE,include=FALSE>>=
opts_chunk$set( fig.path="figure/Core-fig-" ) 
set.seed(123)
@

\def\phbox#1{\fbox{\phantom{g#1l}}}
\def\ffbox#1{\fbox{\phantom{g}#1\phantom{b}}}

\chapter{Menos vólumen, más creatividad}
\label{chap:TheTemplate}
\label{chap:Template}



\begin{quote}
Muchas veces uno termina poniendo muchísimo más volumen, porque está enseñando fundamentos y porque está enseñando conceptos que necesita agregar, pero usted tal vez no los use necesariamente porque son bloques de construcción para otros conceptos y variaciones que van a aparecer de esto... Cuando se está fuera de temporada, se tiene la oportunidad de tomar un paso atrás y adaptarlo más específicamente a su equipo y a sus jugadores. 

\hfill -- Mike McCarthy, Entrenador principal, Green Bay Packers 
\end{quote}

                                          

\begin{quote}
La perfección se logra, no cuando no hay nada más que agregar, pero cuando no hay nada más que quitar 

\hfill -- Antoine de Saint-Exupery,  escritor, poeta, aviador
\end{quote}


\bigskip

\marginnote{Mike McCarthy, entrenador del equipo de fútbol americano Green Bay Packers usa "Menos volumen, más creatividad" como un mantra con su staff de entrenamiento conforme preparan los planes de juego cada semana. Como ilustración del principio de trabajo, cuando un fanático del equipo le pregunta cuantos pases prepara el equipo para un oponente dado, el entrenador contestó, "Cuando entré a la NFL, hacíamos 150 pases en nuestro plan de juego. He puesto un cartel en todas las puertas de coordinadores del equipo - Menos volumen, más creatividad. Funcionamos con más conceptos, con menos volumen. [Ahora] Hacemos alrededor de 50[pases] en un plan de juego"}
\noindent
Una forma clave de introducir \R\ exitosamente es encontrar un conjunto de comandos que sea
\begin{itemize}
	\item {Pequeño}, % fewer is better
    \item {coherente}, y  % commands should be as similar as possible
	\item {poderoso}. % can do what needs doing 
\end{itemize}


Este capítulo proporciona un ejemplo extenso de este abordaje de 
"Menos vólumen, más creatividad". El paquete \pkg{mosaic} (combinado con el paquete \pkg{lattice} y otras funciones del corazón de \R) nos provee una poderosa y simple estructura que equipa a los estudiantes para producir todos los
		\begin{itemize}
			\item
				Resúmenes numéricos, 
			\item
				Resúmenes gráficos, y 
			\item
				Modelos lineales
		\end{itemize}
necesarios en cursos introductorios. Presentando esto como una plantilla maestra con variaciones, le damos énfasis a la similitud entre estos comandos y así reducir la carga cognitiva para los estudiantes. En nuestra experiencia, esto ha hecho \R\ mucho más accesible y disfrutable para los estudiantes e instructores.

\section{El paquete \texttt{mosaic} y la notación de fórmula}

Mucho del primer trabajo del paquete \pkg{mosaic} está centrado en producir un conjunto de comandos de \R mínimo que pudiera brindar a los estudiantes todo lo que necesitan para cursos introductorios de estadística; no sobrecargarlos con demasiados comandos. Una de las viñetas del paquete \pkg{mosaic} incluye un documento describiendo tal conjunto de comandos.

Muchos de estos están construidos a partir de la siguiente notación, que es utilizada frecuentemente.

\begin{center}
	\Large
	\sf
	\phbox{meta} $\Big($
	\phbox{y} $\sim$  \phbox{x} , data = \phbox{datos} $\Big)$
\end{center}
Esta plantilla se puede utilizar llenando las cajas. Sirve darle a cada caja un nombre::
\begin{center}
	\Large
	\sf
	\ffbox{meta} $\Big($ 
	\ffbox{y} $\sim$  \ffbox{x} , data = \ffbox{datos} $\Big)$
\end{center}
\TeachingTip{Después de introducir esta plantilla, tal vez debería evaluar a los estudiantes para saber si la han aprendido. Esto enfatiza su importancia.}

La notación tiene un poco más de flexibilidad que la que se ha indicado. A veces \code{y} no es necesario
<<eval=FALSE>>=
goal( ~ x, data=mydata )
@
\noindent
The formula may also include a third part
<<eval=FALSE>>=
goal( y ~ x | z , data=mydata )
@
\noindent
La fórmula puede incluir una tercera parte 
<<eval=FALSE>>=
goal( formula , data=mydata )
@

Esta notación puede ser aplicada para crear resúmenes numéricos, resúmenes gráficos o ajustes de modelos haciéndose 
dos preguntas y usando las preguntas para llenar los espacios de la notación (plantilla).

\myindex{two questions|see{questions!two}}
\myindex{questions!two}

\begin{enumerate}
	\item ¿Qué quiere que haga \R? 
	
	Esta, es la meta  


	\item ¿Qué debe saber R para saber eso? 

		Estas son las entradas que de la función. Para resúmenes numéricos, resúmenes gráficos y
		ajustes de modelos, típicamente necesitamos especificar las variables envueltas y el
		conjunto de datos en el que están guardadas.
\end{enumerate}

\section{Resúmenes gráficos de datos}

%\TeachingTip[-2cm]{We recommend showing some plots on the first day and having students
%generate their own graphs before the end of the first week.}
%
Los resúmenes gráficos son una importante y vistosa forma de demostrar el poder y flexibilidad de nuestra notación. Nos gusta introducir a los estudiantes a resúmenes gráficos prontamente en el curso. Esto les da a los estudiantes acceso a una funcionalidad de \R\ que destaca (y es muchísimo mejor que una calculadora a la mano). También empieza a desarrollar su habilidad de interpretar representaciones gráficas de datos, pensar en distribuciones y plantear preguntas estadísticas.


\Rindex{gplot2}
\Rindex{lattice}
\Rindex{ggvis}
\Pointer[-1cm]{Seguido nos preguntan sobre otros sistemas gráficos, especialmente los gráficos \pkg{ggplot2}. En nuestra experiencia, \pkg{lattice} hace más fácil para principiantes crear una amplia variedad de gráficos más o menos estandarizados -- incluyendo la habilidad de representar varias variables al mismo tiempo. \pkg{ggplot2}, por otra parte, hace más fácil generar gráficos personalizados o combinar componentes de gráficos. Cada una tiene su lugar, y nosotros utilizamos ambos sistemas. Pero para principiantes, típicamente enfatizamos \pkg{lattice}.

El nuevo paquete \pkg{ggvis}, por los autores de \pkg{ggplot2} agrega interactividad y velocidad a los gráficos para fortalecer \pkg{ggplot2}.}

%
Hay bastantes formas de hacer gráficos en \R. Un abordaje es el sistema de los gráficos llamados \pkg{lattice}. Siempre que se carga el paquete \pkg{mosaic}, el paquete \pkg{lattice} es cargado también. Uno de sus aspectos atractivos es que usa la misma notación (plantilla) que usamos para resúmenes y modelos lineales.

\subsection{Resúmenes gráficos de dos variables}



\subsubsection{Un primer ejemplo: haciendo un gráfico de dispersión}

Como ejemplo. Creemos el siguiente gráfico, que muestra el número 
de nacimientos en Estados Unidos para cada día en 1978. 

\myindex{scatter plot|see{\texttt{xyplot()}}}
\Rindex{xyplot()}

<<scatter-births, echo=FALSE, fig=TRUE>>=
xyplot(births ~ date, data=Births78) 
@

\TeachingTip[-2cm]{Este gráfico puede generar una discusión interesante al inicio del curso. Pídale a los estudiantes hacer conjeturas sobre patrones en los gráficos. Sus respuestas revelarán sin están interpretando bien los gráficos.}

\begin{enumerate}
	\item ¿Cuál es la meta?

		Queremos un gráfico de dispersión. La función que crea gráficos de dispersión se llama
		xyplot(), entonces esta meta llena una parte de nuestra plantilla.

	\item
		¿Qué necesita saber \R\ ?

		\R\ necesita saber cuál variable va donde y donde encontrar las variables. En este caso,
		los datos están guardados en el conjunto de datos \dataframe{Births78}.
\Rindex{Births78}
<<>>=
head(Births78)
@
		Queremos poner 
		el número de nacimientos (\variable{births}) en el eje y,  
		y el día del año (\variable{date}) en el eje x.

\end{enumerate}
Poniendo todo junto, genera el siguiente comando
<<eval=FALSE>>=
<<scatter-births>>
@

\newpage

\vspace*{-1cm}
\subsubsection{Otro ejemplo: Diagramas de cajas}

\myindex{boxplot|see{\texttt{bwplot()}}}
\Rindex{bwplot()}
Ahora generemos este gráfico, que muestra diagramas de cajas para cada una de las tres sustancias de abuso utilizadas por participantes en los ensayos clínicos aleatorizados de \emph{Health Evaluation and Linkage to Primary Care} 
\Pointer{Puede encontrar más sobre información del conjunto de datos \dataframe{HELPrct} usando el comando de ayuda: 
\code{?HELPrct}. Este le brindará ayuda con el libro de código para los datos y enlaces de la fuente original.

También hay unas cuantas funciones que permiten inspeccionar contenidos de un conjunto de datos. Entre nuestros favoritos están \function{inspect()}, \function{glimpse()}, y \function{head()}.}

\Rindex{HELPrct}
<<bwplot-example1, echo=FALSE>>=
bwplot(age ~ substance, data=HELPrct)
@

Los datos que necesitamos están en el conjunto de datos \dataframe{HELPrct}, del cual queremos desplegar las variables año y sustancias en los ejes \code{y} y \code{x}. De acuerdo a nuestra notación, el comando para crear este gráfico tiene la forma

<<eval=FALSE>>=
meta(age ~ substance, data=HELPrct)
@

La única información adicional que necesitamos es el nombre de la función que crea los diagramas de caja. Esta función es \function{bwplot()}. Entonces podemos crear el gráfico con 
<<eval=FALSE>>=
<<bwplot-example1>>
@

Para hacer los gráficos de caja horizontales en lugar de verticales, invierta la posición de \variable{age} y \variable{substance}:

<<fig=TRUE>>=
bwplot(substance ~ age, data=HELPrct)
@

\Pointer{Podrá estar preguntándose sobre gráficos para dos variables categóricas. Un gráfico comúnmente usado para esto es el gráfico de barras segmentadas. Vamos a tratar esto como una versión aumentada de un gráfico de barras simple, que es un resumen gráfico de una variable categórica.

Otro gráfico que puede usar para desplegar dos (o más) variables categóricas es un gráfico \function{mosaic()}. El paquete \pkg{lattice} no incluye los gráficos mosaic, sin embargo, el paquete \pkg{vcd} proporciona una función \function{mosaic()} que crea gráficos mosaic.}
\Rindex{vcd}
\myindex{mosaic plot}


\subsection{Resúmenes gráficos de una variable}

Si queremos hacer un gráfico que incluya solamente una variable, 
simplemente omitimos la parte de \code{y} de la fórmula. Por ejemplo, 
un histograma como 
\Rindex{histogram()}

<<historam-example1, echo=FALSE, fig=TRUE>>=
histogram( ~ age, data=HELPrct) 
@
\Caution{Es importante notar que cuando hay solamente una variable, esta tiene que estar \emph{a la derecha de la fórmula}.}

%
puede ser hecho con
\TeachingTip{Dígale a los estudiantes que dado que R está computando 
los valores de \code{Y}, nosotros no necesitamos proporcionárselos. Esta no es exactamente la razón por la cual esto es de esta forma, pero les va ayudar a recordar.}
%
<<eval=FALSE, echo=TRUE>>=
histogram( ~ age, data=HELPrct) 
@
\InstructorNote{Introducir \option{width} y \option{center} aquí es, en efecto, una violación a nuestra política usual de aceptar predeterminados y guardando opciones para más tarde. Pero es importante que las cajas del histograma sean elegidas apropiadamente, y el predeterminado algoritmico no funciona bien para todos los conjuntos de datos. Motivamos a los estudiantes a hacer algunos histogramas  y experimentar con el centro y especialmente con el ancho. }
El paquete \pkg{mosaic} agrega alguna otra funcionalidad a \function{histogram()}, para hacer más fácil especificar las clases pendientes. En particular, las opciones del ancho y del centro(el predeterminado es 0) puede ser usado para definir el ancho de las clases o el centro de una de las clases. Por ejemplo, para crear un histograma con clases que sean de un ancho de 5 años, se puede usar \option{width=5}, y podemos cambiarlas de izquierda a derecha cambiando el valor del centro. 


<<out.width=".47\\textwidth", fig=TRUE>>=
histogram( ~ age, data=HELPrct, width=5) 
histogram( ~ age, data=HELPrct, width=5, 
           center=2.5) 
@

\Note{El centro no necesita ser contenido en las clases que son desplegadas. Entonces consiga clases con límites "en 0's y 5's", podemos hacer el centro 2.5, aunque no esté en el rango de datos.}

Hay datos suficientes para utilizar una barra para cada número entero si queremos. Como el valor predeterminado de centro es 0, ajustar el ancho a 1 centra las clases en los enteros, evitando confusiones potenciales de cual límite es incluido en la barra.
<<fig=TRUE>>=
histogram( ~ age, data=HELPrct, width=1) 
@
\Rindex{bargraph()}
Para una única variable categórica, 
podemos hacer un gráfico de barras, usando \function{bargraph()} 
en lugar de \function{histogram()}. Puesto que las fórmulas son requeridas al lado derecho, los gráficos de barra horizontales son producidos utilizando \option{horizontal = TRUE}
\Rindex{barchart()}
\Pointer{La función \function{bargraph()} no está en el paquete \pkg{lattice}, pero está en el paquete \pkg{mosaic}. La funcion de \pkg{lattice} \function{barchat()} crea gráficos de barra para datos \emph{resumidos}; \function{bargraph()} ya se encarga de crear este resumen de datos y después usar \function{barchat()} para crear el gráfico.}
<<out.width=".47\\textwidth", fig=TRUE>>=
bargraph( ~ substance, data=HELPrct) 
bargraph( ~ substance, data=HELPrct, horizontal=TRUE) 
@

\subsection{La gama de gráficos}
\label{sec:paletteOfPlots}
\Pointer{Si usted no está familiarizado con algunos gráficos, como los ashplots y los polígonos de frecuencia, siga leyendo. Tenemos más que decir de ellos pronto.}

El poder de la notación (plantilla) es que ahora podemos hacer diferentes tipos de gráficos imitando los ejemplos anteriores pero cambiando la meta.
%(The plots appear in Figure~\ref{fig:one-var-plots}.)

\Rindex{densityplot()}
\Rindex{freqpolygon()}
\Rindex{dotPlot()}
\Rindex{qqmath()}
\Rindex{ashplot()}
<<one-var-plots, eval=FALSE, tidy=TRUE, out.width=".45\\textwidth">>=
  histogram( ~ age, data=HELPrct) 
freqpolygon( ~ age, data=HELPrct) 
    dotPlot( ~ age, data=HELPrct, width=1) 
    ashplot( ~ age, data=HELPrct, width=1) 
densityplot( ~ age, data=HELPrct) 
     qqmath( ~ age, data=HELPrct) 
     bwplot( ~ age, data=HELPrct) 
     bwplot( ~ age, data=HELPrct, pch = "|")  
@

%\begin{figure}
<<echo=FALSE, out.width=".45\\textwidth", fig=TRUE>>=
  histogram( ~ age, data=HELPrct) 
freqpolygon( ~ age, data=HELPrct) 
    dotPlot( ~ age, data=HELPrct, width=1) 
    ashplot( ~ age, data=HELPrct, width=1) 
densityplot( ~ age, data=HELPrct) 
     qqmath( ~ age, data=HELPrct) 
     bwplot( ~ age, data=HELPrct) 
     bwplot( ~ age, data=HELPrct, pch = "|")  
@
%\caption{Some one-variable plots.}
%\label{fig:one-var-plots}
%\end{figure}
%\Note[-4cm]{If you prefer the more traditional boxplot display with a line at the median
%rather than a dot, you can make that the default behavior with
%\code{trellis.par.set(box.dot = list(pch = "|")).}}

\noindent
Algunas personas prefieren el diagrama de cajas desplegado de una forma más tradicional, con una línea en la mediana en lugar de un punto. Podemos hacer esto un comportamiento predeterminado usando.

<<>>=
trellis.par.set(box.dot = list(pch = "|"))
@

\newpage
Para una variable categorica, podemos usar un gráfico de barras
\Note{El paquete \pkg{lattice} no suministra una función para crear gráficos de tipo pastel. Esto no es una gran pérdida puesto que es generalmente más difícil hacer comparaciones con estos gráficos.}
<<out.width = "0.45\\textwidth", fig=TRUE>>=
   bargraph( ~ sex, data=HELPrct)  
     # Variable categórica
@

\Rindex{plotPoints()}
<<two-var-plots, eval=FALSE, tidy=FALSE>>=
    xyplot( width ~ length, data=KidsFeet)  # 2 variables cuantitativas
plotPoints( width ~ length, data=KidsFeet)  # Una alternativa a mosaic
    bwplot(length ~ sex,    data=KidsFeet)  # 1 categórica, 1 cuantitativa
    bwplot(   sex ~ length, data=KidsFeet)  # roles inversos
@
<<echo=FALSE, out.width=".47\\textwidth", fig.keep='all'>>=
<<two-var-plots>>
@

\Caution{Hay una función llamada \function{dotPlot()} (con P mayúscula). Note que \function{dotplot()} produce un resultado muy diferente al gráfico que produce \function{dotPlot()}}

El paquete \pkg{lattice} también ofrece las funciones \function{striplot()} y \function{dotplot()} pueden ser usadas para un gráfico de dispersión unidimensional. Esto trabaja razonablemente bien para conjuntos de datos pequeños, pero tiene una utilidad limitada para conjuntos de datos grandes.
\Rindex{dotplot()}
\Rindex{stripplot()}
<<out.width=".47\\textwidth", fig.show='hold', fig.keep='all', fig=TRUE>>=
stripplot( ~ length, data=KidsFeet)
  dotplot( ~ length, data=KidsFeet)
@

\TeachingTip{Usualmente no introducimos la función \function{dotplot()} y la función \function{stripplot()} a los estudiantes, simplemente usamos la función \function{xyplot().}} Estos \function{xyplot()} o \function{plotPoints()} pueden también ser usados con una variable cuantitativa y una variable categorica
<<tidy=FALSE, out.width=".42\\textwidth">>=
    xyplot(sex ~ length, data=KidsFeet)
plotPoints(sex ~ length, data=KidsFeet)
 stripplot(sex ~ length, data=KidsFeet)
   dotplot(sex ~ length, data=KidsFeet)
@

\subsection{Grupos y sub-gráficos}

Podemos agregar variables adicionales a nuestros gráficos tanto trasponiendo múltiples gráficos como ubicando múltiples gráficos uno al lado del otro en la cuadrícula. Para trasponer gráficos, agregamos un argumentos extra a nuestra plantilla, usando \option{groups =} ; y para crear sub-gráficos (llamados paneles en \pkg{lattice} y facetas en \pkg{ggplot2}) usando la fórmula

<<eval=FALSE>>=
y ~ x | z
@

Por ejemplo, podemos sobreponer un gráfico de densidad para la edad para cada grupo de sustancia en paneles separados para cada sexo:

<<tidy=FALSE, fig=TRUE>>=
densityplot( ~ age | sex, data=HELPrct,  
               groups=substance,  
               auto.key=TRUE)   
@
\myindex{legends}
\myindex{facets|see{conditional plots}}
\myindex{conditional plots}

\code{auto.key=TRUE} agrega una leyenda simple, la cual podemos ver sobre las curvas, diciéndonos cual es cual. 

\section{Resúmenes numéricos}

\Note{Lo importante que se debe resaltar en esta sección es lo poco que hay que aprender luego de que se aprende a hacer gráficos. Simplemente se cambia el nombre del gráfico al de una estadística de resumen y está listo.}
Los resúmenes numéricos pueden ser creados de la misma forma, simplemente tenemos que reemplazar el nombre del gráfico con el nombre de algún resumen numérico que deseamos. Nada más cambia; una media y un histograma resume una única variable, entonces cambiando \function{histogram()} por \function{mean()} nos da el resumen que queremos.

\Rindex{mean()}
<<fig=TRUE>>=
histogram( ~ age, data=HELPrct)
     mean( ~ age, data=HELPrct)
@

\Pointer[-2cm]{Para ver la lista completa de estos resúmenes numéricos, use \code{help(favstats)}.}

\Rindex{sd()}
\Rindex{var()}
\Rindex{median()}
\Rindex{min()}
\Rindex{max()}
\Rindex{sum()}
\Rindex{IQR()}
\Rindex{favstats()}
El paquete \pkg{mosaic} incluye versiones de varios resúmenes numéricos con notación de fórmula, incluyendo

El paquete \pkg{mosaic} incluye versiones de varios resúmenes numéricos con notación de fórmula, incluyendo
\function{mean()},
\function{sd()},
\function{var()},
\function{min()},
\function{max()},
\function{sum()},
\function{IQR()}.
Además de \function{favstats()}, una función que computa varias de nuestras estadísticas favoritas:
<<>>=
favstats( ~ age, data=HELPrct)
@

\Rindex{tally()}
La función \function{tally()} puede ser usada para contar casos

<<>>=
tally( ~ sex, data=HELPrct)
tally( ~ substance, data=HELPrct)
@
En ocasiones es conveniente desplegar proporciones o porcentajes.

<<>>=
tally( ~ substance, data=HELPrct, format="percent")
tally( ~ substance, data=HELPrct, format="proportion")
@

Las estadísticas de resumen pueden ser computadas separadamente para múltiples sub-conjuntos de datos. Esta forma es análoga a la graficación de múltiples variables y puede ser pensada de 3 formas. Cada una tiene el mismo valor.

<<>>=
# Edad dependiente de sustancia
sd(   age ~ substance, data=HELPrct)
# Edad separada por sustancia
sd( ~ age | substance, data=HELPrct)
# Edad agrupada por sustancia
sd( ~ age, groups=substance, data=HELPrct)
@
La función \function{favstats()} puede computar varios resúmenes para cada sub-conjunto.

<<>>=
favstats(age ~ substance, data=HELPrct)
@

Similarmente, podemos crear tablas de dos por dos que muestren conteos o proporciones.

<<>>=
tally(sex ~ substance, data=HELPrct)
tally( ~ sex + substance, data=HELPrct)
@

Los totales marginales pueden ser agregados con \option{margins=TRUE}
<<>>=
tally(sex ~ substance, data=HELPrct, margins=TRUE)
tally( ~ sex + substance, data=HELPrct, margins=TRUE)
@

\section{Modelos lineales}
\myindex{linear models|seealso{\texttt{lm()}}}
\Rindex{lm()}

Aunque no hemos mencionado los modelos lineales aún, estos son una motivación importante para el patrón de abordaje de los resúmenes gráficos y numéricos. El sistema gráfico \pkg{lattice} y el paquete \pkg{mosaic} hace posible hacer resúmenes numéricos y resúmenes gráficos con la misma notación. Introduciendo a los estudiantes a la notación para gráficos y resúmenes numéricos, hay muy poco que enseñarles cuando tengan que aprender a ajustar un modelo.
\FoodForThought[-2cm]{Probablemente usted está pensando que no necesitamos esperar tanto para introducir el modelaje en los cursos de estadística introductoria. Nosotros pensamos lo mismo. Vea el volumen acompañante, {\em Start Modeling in R}.}


Por ejemplo, suponemos que queremos saber cómo el ancho de los pies de los niños, depende del largo del pie. Podemos usar un gráfico de dispersión y podemos construir un modelo lineal usando la misma notación.
<<fig=TRUE>>=
xyplot(width ~ length, data=KidsFeet)
    lm(width ~ length, data=KidsFeet)
@
Vamos a tener más que decir sobre el modelaje en otras partes. Por ahora, el punto es que nuestro uso de la notación para resúmenes gráficos y numéricos prepara a los estudiantes para preguntarse cómo \code{Y} depende de \code{X} y concretar modelos de dos o más variables cuando sea el momento.

\section{Otras pruebas}

Algunos cursos introductorios de estadística introducen a los estudiantes pruebas de hipótesis para una o dos muestras, tanto para medias como para proporciones. El paquete \pkg{mosaic} permite utilizar esta notación también.
\Pointer{Para un tratamiento más exhaustivo de cómo usar \R\ para temas importantes en un curso tradicional de estadística introductoria, vea \emph{Una guía de estudiantes para R}}%

%\authNote{We could use better examples here.  -- rjp 2014-06-21}%
\Rindex{t.test()}
<<tidy=FALSE>>=
t.test( ~ length, data=KidsFeet)
@
La salida que generan estas funciones incluye más de lo que realmente necesitamos. El paquete \pkg{mosaic} nos brinda las funciones \function{pval()} y \function{confint()} para extraer p-values e intervalos de confianza:
\Rindex{pval()}
\Rindex{confint()}
<<>>=
pval(t.test( ~ length, data=KidsFeet))
confint(t.test( ~ length, data=KidsFeet))
@

\Pointer[0.5cm]{La prueba de ji-cuadrado puede ser realizada usando la función \function{chisq.test()}. Esta función es un poco diferente pues opera en datos tabulados, como del tipo producidos por la función \function{tally()} en lugar de con los datos. Entonces, el uso de la notación pasa en \function{tally()} en lugar de en \function{chisq.test}}
\Rindex{binom.test()}
\Rindex{prop.test()}
\begin{widestuff}
<<echo=FALSE>>=
OLD <- options(width=100)
@
<<>>=
confint(t.test(length ~ sex, data=KidsFeet))
@

<<>>=
# Usando la distribución binomial
confint(binom.test( ~ sex, data=HELPrct))  
@
<<>>=
# Usando la aproximación normal de la distribución binomial
confint(prop.test( ~ sex, data=HELPrct))    
confint(prop.test(sex ~ homeless, data=HELPrct))
@
<<echo=FALSE>>=
options(OLD)
@

\end{widestuff}

\section{Las exquisiteces de \texttt{lattice}}

En los gráficos que le hemos mostrado, nos hemos enfocado en crear una variedad de gráficos útiles y  hemos aceptado (la mayor parte del tiempo) la forma presentación predeterminada de estos. El sistema de gráficos \pkg{lattice} proporciona muchas exquisiteces que pueden ser introducidas una vez que las plantillas de gráficos han sido bien aprendidas. Argumentos opcionales de las funciones graficas pueden ser utilizados para agregar o modificar lo siguiente
\begin{itemize}
	\item
		La ventana en la que se ve,
	\item
		título,
	\item
		nombre de los ejes
	\item
		colores, formas, tamaños y tipos de linea,
	\item
		transparencia,
	\item
		tipo de letra
	\end{itemize}
y otras características de los gráficos

Nuestro consejo es guardar esas exquisiteces para cuando un estudiante pregunte o un análisis lo requiera. 


\subsection{Ejemplo: Número de nacimientos por día.}
\label{sec:births-lines}
Hemos visto los datos de \dataframe{Births78} en la sección 3.2. Los gráficos abajo toman ventaja de argumentos adicionales para mejorar el gráfico.
\Pointer{\texttt{\%\%} lleva a cabo un modular aritmético, en este caso dando 7 grupos, cada uno de ellos es un día de la semana}
%
El primer gráfico ilustra una de las características más importantes de este conjunto de datos -- hay usualmente menos nacimientos en dos días de la semana y más en los otros cinco. 
%
\Pointer[1cm]{Algunos argumentos aquí usan listas(list). Este es uno de los "tipos contenedores" fundamentales de \R. Los instructores pueden obtener beneficios de saber reconocerlos. Vamos a hablar de ellos en el capítulo 7.}%
FDe lo que podemos estar seguros es que es que el año en 1978 inició un domingo.
\Pointer{También podemos usar la función \function{wday()} en el paquete \pkg{lubridate} para conseguir el día de se la semana directamente de \variable{date}.} %

\Rindex{auto.key}
\myindex{labels!axis}
\Rindex{xlab}
\Rindex{ylab}
\Rindex{main}
\myindex{titles (plots)}
\Rindex{par.settings}
<<fig.width=4, tidy=FALSE>>=
xyplot(births ~ date, data=Births78,  
        groups=dayofyear %% 7, 
        auto.key=list(columns=4),
        main="Nacimientos en US por día 1978",
        xlab="day of year",
        ylab="# of births",
        par.settings=list(
          superpose.symbol=list(pch=16, 
                                cex=.8, 
                                alpha=.8))
)
@

Aquí, hemos usado
\Rindex{pch}
\Rindex{cex}
\Rindex{alpha}
\myindex{plot symbol!shape|see{\texttt{pch}}}
\myindex{plot symbol!size|see{\texttt{cex}}}
\myindex{transparency|see{\texttt{alpha}}}
\myindex{opacity|see{\texttt{alpha}}}
\begin{itemize}
	\item
		\option{auto.key} para el control del esquema de la leyenda (4 columnas en lugar de 1)
	\item
		\option{main} , para ponerle título al gráfico 
	\item
		\option{xlab} y \option{ylab} para nombrar los ejes del gráfico 
	\item
		\option{par.settings} para ajustar los simbolos o caracteres del gráfico (\option{pch}),
		el tamaño de estos (\option{cex}), y la opacidad (\option{alpha})
		para los gráficos traslapados  (\option{superpose.symbol}).
\end{itemize}


El siguiente gráfico usa lineas en lugar de puntos, lo cual hace más fácil localizar parte de las observaciones inusuales.
<<fig.width=4, tidy=FALSE>>=
xyplot(births ~ date, data=Births78,  
  groups=wday, type='l',
  main="Nacimientos en US por día en 1978",
  auto.key=list(columns=4, lines=TRUE, points=FALSE),
  xlab="day of year",
  ylab="# of births"
)
@

\subsection{Temas}
\Rindex{theme.mosaic()}
Los ajustes que son usados repetidamente pueden ser reunidos en un tema. El paquete mosaic proporciona un tema llamado \function{theme.mosaic()}. La función \function{show.settimgs()} despliega los ajustes del tema que está activo.


\Rindex{trellis.par.set()}
\Rindex{show.settings()}
\myindex{\texttt{lattice} settings}
\myindex{themes!\texttt{lattice}|see{\texttt{trellis.par.set()}}}

<<out.width=".8\\textwidth", fig.width=10, fig.height=6>>=
trellis.par.set(col.whitebg())
show.settings()
@

\Pointer{En la versión impresa de este libro, los tres ejemplos aparecen en blanco y negro y fueron procesadas con theme.mosaic(bw=TRUE). En la versión online, el primer y tercer ejemplo aparecen en color}

<<out.width=".8\\textwidth", fig.width=10, fig.height=6, fig=TRUE>>=
trellis.par.set(theme.mosaic(bw=TRUE))
show.settings()
@

<<out.width=".8\\textwidth", fig.width=10, fig.height=6, fig=TRUE>>=
trellis.par.set(theme.mosaic())
show.settings()
@

\noindent
Los temas también puede ser asignados a los \option{par.settings} si queremos afectar únicamente un gráfico
<<fig.width=4, tidy=FALSE, fig=TRUE>>=
xyplot(births ~ date, data=Births78,  
  groups=wday, type='l',
  main="Nacimientos en US por día en 1978",
  auto.key=list(columns=4, lines=TRUE, points=FALSE),
  par.settings=theme.mosaic(bw=TRUE),
  xlab="day of year",
  ylab="# of births"
)
@

\subsection*{Some Examples}

\section{Algunos ejemplos adicionales}

\subsection{Gráficos de puntos}

Los gráficos de puntos no son usualmente vistos en las lecturas estadísticas como se ven en la educación estadística, donde pueden tomar un rol importante en ayudar a los estudiantes a aprender e interpretar histogramas (y polígonos de frecuencias y gráficos de densidad). Un gráfico de puntos representa cada valor de una variable cuantitativa con un punto. Los valores son redondeados un poco para que los puntos logren alinearse de la mejor manera, y los puntos son apilados en pequeñas torres cuando los valores de los datos en el cluster están muy cerca uno del otro. Los gráficos de puntos son primariamente utilizados cuando se tienen conjuntos de datos de tamaño modesto y que puede ser utilizado como puente o conexión para otros gráficos, cuando no es una conexión entre el componente de un gráfico y la observación individual.

\Rindex{dotPlot()}
Aquí hay un ejemplo de la utilización de las medidas de sépalo guardadas en el conjunto de datos \dataframe{iris}


<<rs2-dotPlot,cache=FALSE,fig.width=4,fig.height=3.0,out.width=".75\\textwidth", tidy=FALSE, fig=TRUE>>=
dotPlot(~ Sepal.Length, data=iris, 
		n=30,      # approx. 30 bins/columns
		alpha=.6)  # partially transparent
@
\TeachingTip[-2cm]{Los gráficos de puntos son útiles para desplegar distribuciones muestrales y distribuciones de bootstrap, especialmente si el número total de puntos es elegido para que sea algo simple, como 1000. En ese caso las probabilidades pueden ser estimadas contando puntos.}
Podemos usar una variable condicional para separar los gráficos de puntos para cada tres especies en este conjunto de datos.
<<rs2-dotPlot-condB,tidy=FALSE,cache=FALSE,out.width=".75\\textwidth",fig.width=6, fig=TRUE>>=
dotPlot(~ Sepal.Length | Species, data=iris, n=20, 
         layout=c(3,1)) # 3 columnas (x) y 1 fila (y)
@

La conexión entre los histogramas y los gráficos de puntos puede ser visualizada poniendo uno encima del otro
\Rindex{histogram()}
<<echo=FALSE,fig.height=2.3, fig=TRUE>>=
histogram(~ Sepal.Length, data=iris, n=25, 
		  panel=function(x,...) {
			  mosaic:::panel.xhistogram(x, alpha=.7, ...)
			  mosaic:::panel.dotPlot(x, pch=1, cex=.9, col="gray80", alpha=.7, ...)
		  }, 
			  type="count") 
@

\subsection{Polígonos de frecuencia: \texttt{freqpolygon()}}
\Rindex{freqpolygon()}
\myindex{frequency polygon|see{\texttt{freqpolygon()}}}

Los \term{polígonos de frecuencia} y \term{los gráficos de densidad proveen una alternativa}, diferente a los histogramas que hace más fácil sobreponer representaciones a distintos grupos de datos. Un polígono de frecuencia es creado del mismo resumen de datos (conteos y clases) que un histograma, pero en lugar de representar cada clase con una barra, es representada con un punto (en el centro donde está lo más alto de la barra del histograma).  

Estos puntos son conectados con una línea. Aquí se muestra un ejemplo que muestra la distribución de los tiempos de erupción de una secuencia de observaciones del conjunto de datos faithful. 

\Caution{El conjunto de datos \dataframe{faithful} contiene datos similares, pero los nombres de la variable están escogidos extrañamente. El set de datos \dataframe{geyser} en el paquete \pkg{MASS} tiene mejores nombres y más datos.}
\Rindex{MASS}
\Rindex{geyser}
<<fig=TRUE>>=
require(MASS)
freqpolygon( ~ duration, data=geyser, n=15)
@

\TeachingTip[-1.5in]{Haga ver que hay una característica interesante de esta distribución, una clara bimodalidad. En particular, la media y la mediana en este caso no son buenas medidas para la duración "típica" de una erupción, puesto que casi ninguna de las duraciones de la erupción está cerca dela media y la mediana.}
Numéricamente, los datos están siendo resumidos y representados en exactamente la misma forma que con los histogramas, pero visualmente las líneas horizontales y verticales del histograma son reemplazadas por líneas con cierta pendiente. 

\Rindex{ladd()}
<<echo=FALSE, fig=TRUE>>=
histogram( ~ duration, data=geyser, n=15, col="lightskyblue")
ladd(panel.freqpolygon(geyser$duration, n=15))
@


Esto puede dar una representación visual más precisa en algunas situaciones (puesto que la distribución puede ser un mejor "concluyente"). Más importante, hace muchísimo más fácil sobreponer múltiples distribuciones.

<<tidy=FALSE>>=
freqpolygon( ~ Sepal.Length, data=iris, 
			groups=Species, 
			ylim=c(0,1.5)  # Ajustar el eje y manualmente
)
@

\subsection{Gráficos ASH: histogramas de promedio desplazado}
\Rindex{ashplot()}

Los histogramas son sensibles a la elección del ancho de las clases y los bordes (o centros). Una forma de reducir esta dependencia son los gráficos ASH o histogramas de promedio desplazado. La altura de un gráfico ASH es la altura promedio de todos los histogramas con anchos de clase cambiados. Si está familiarizado con los gráficos de densidad (discutidos en la siguiente sección), un gráfico ASH se los recordará, pero son más fáciles de explicar a principiantes.

<<fig=TRUE>>=
ashplot( ~ Sepal.Length, data=iris, groups=Species, 
         width = 1.0, main = "width = 1.0")
ashplot( ~ Sepal.Length, data=iris, groups=Species, 
         width = 0.25, main = "width = 0.25")
@


\subsection{Gráficos de densidad: \texttt{densityplot()}}
\Rindex{densityplot()}


Los gráficos de densidad son similares a los polígonos de frecuencia, pero la representación lineal pieza por pieza es reemplazada por una curva suavizada.
<<fig=TRUE>>=
densityplot( ~ Sepal.Length, data=iris, groups=Species)
@
Los principiantes no necesitan saber muchos detalles sobre como una curva suavizada es generada, pero debe ser introducido el argumento de \option{adjust} que controla el grado de suavizamiento. Es difícilmente equivalente elegir entre clases con intervalos más largos o más anchos para un histograma o un polígono de frecuencia. El valor predeterminado es 1. Los valores mayores suavizan más drásticamente; los valores menores, menos.

<<tidy=FALSE, out.width=".47\\textwidth", fig=TRUE>>=
densityplot( ~ Sepal.Length, data=iris, groups=Species, 
             adjust=3, main="adjust=2")
densityplot( ~ Sepal.Length, data=iris, groups=Species, 
             adjust=1/3, main="adjust=1/2")
@

\subsection{La escala de densidad}
\myindex{density scale}

Hay tres escalas que pueden ser usadas para los gráficos en la sección precedente: 
\code{conteo}, 
\code{porcentaje}, 
y \code{densidad}.  
Los estudiantes iniciando van a estar más relacionados con la escala de \code{conteos} y posiblemente también la de \code{porcentaje}. La escala de \code{densidad} captura los aspectos más importantes de estos gráficos:

\begin{boxedText}
	\centerline{El área es equivalente a la proporción.}
\end{boxedText}

\noindent
La escala de densidad es escogida, de tal forma que la proporcionalidad es 1, en este caso tenemos que
\begin{boxedText}
	\centerline{El área equivale a la proporción.}
\end{boxedText}
\TeachingTip[-1.5cm]{Haga algunos histogramas o polígonos de frecuencia con una escala de densidad y vea si sus estudiantes pueden determinar la escala. Elegir anchos de clase convenientes (pero no 1) y comparar gráficos con diferentes anchos de clase y diferentes tipos de escala puede ayudarlos a conjeturar acerca de la escala de densidad.}
Esta es la única escala disponible para \function{densityplot()} y es la escala más adecuada si se está primariamente interesado en la \emph{forma} de la distribución. La escala vertical es poco afectada por la elección del ancho de clase o los multiplicadores de \option{adjust}. Es también la escala apropiada para utilizar cuando se sobrepone una función de densidad en un histograma, algo que el paquete mosaic hace fácil.
<<fig.width=6,out.width="\\textwidth", tidy=FALSE, fig=TRUE>>=
histogram( ~ Sepal.Length | Species, data=iris, fit="normal")
@

Las otras escalas son de uso primariamente cuando uno quiere poder leer los conteos de clase o porcentajes del gráfico

\subsection{¿Grupos o paneles?}

\myindex{conditional plots}
\Rindex{iris}
\Rindex{xyplot}
El siguiente ejemplo, que utiliza el conjunto de datos \dataframe{iris}, nos muestra una comparación con el uso de grupos o paneles para separar subconjuntos de datos. Primero ponemos tres especies en tres paneles diferentes.

<<rs2-iris-xyplot-cond,tidy=FALSE,cache=TRUE,fig.width=6,out.width=".8\\textwidth", fig=TRUE>>=
xyplot(Sepal.Length ~ Sepal.Width | Species, data=iris,
  layout=c(3,1)) # Los controles de diseño
#(layout) controlan el número de columnas y filas
@

Alternativamente, podemos usar el argumento de grupos para indicar las diferentes especies, usando diferentes símbolos en el mismo panel.
\Rindex{auto.key}
<<rs2-iris-xyplot-groups,cache=TRUE,tidy=FALSE, fig=TRUE>>=
xyplot(Sepal.Length ~ Sepal.Width, groups=Species, 
  auto.key=list(columns=3), data=iris)
@

En ocasiones es de gran ayudar usar ambos, los paneles y los grupos por símbolo.


<<rs2-iris-xyplot-condgroups,cache=TRUE,tidy=FALSE, fig=TRUE>>=
xyplot(Sepal.Length ~ Sepal.Width | Species, groups=Species, 
  auto.key=list(columns=3), data=iris)
@


\subsection{Lidiando con etiquetas largas}

Suponga que queremos desplegar la siguiente tabla (basada en los datos de la encuesta de población de Estados Unidos de 1985) usando gráficos de barras.
\Rindex{CPS85}
\myindex{Current Population Survey|see{\texttt{CPS85}}}
\Rindex{tally()}
<<>>=
tally( ~ sector, data=CPS85)
@
La función de \pkg{mosaic} \function{bargraph()} puede mostrar estas tablas como gráficos de barras, pero no hay suficiente espacio para las etiquetas
\Rindex{bargraph()}
<<rs2-bargraph1,tidy=FALSE, fig=TRUE>>=
bargraph(~ sector, data=CPS85)
@
Una solución a esto puede ser utilizar barras horizontales
<<rs2-bargraph2a, fig=TRUE>>=
# barras horizontales
bargraph(~ sector, data=CPS85, horizontal=TRUE)  
@
Otra puede ser rotar las etiquetas.
<<rs2-bargraph1a,tidy=FALSE, fig=TRUE>>=
bargraph(~ sector, data=CPS85, 
                   scales=list(x=list(rot=45)))
@

Y como con otros gráficos \pkg{lattice}, podemos agregar condiciones de agrupamiento o condicionar nuestro gráfico.
<<rs2-bargraph3a,tidy=FALSE, tidy=FALSE, out.width=".47\\textwidth", fig=TRUE>>=
bargraph(~ sector, data=CPS85, groups=race, 
                   auto.key=list(space="right"),
                   scales=list(x=list(rot=45)))
bargraph(~ sector | race, data=CPS85, 
                          scales=list(x=list(rot=45)))
@

%\iffalse
%Just as bar charts are used to display the distribution of one categorical
%variable,  \pkg{mosaic} plots can do the same for cross tables.
%The \function{mosaic()} function (from the \pkg{vcd} package) is not a \pkg{lattice} plot, 
%but it does use a similar formula interface.  

%<<rs2-mosaic1,fig.width=4,fig.height=2>>=
%require(vcd)                         # load the visualizing categorical data package
%mosaic(~ sex + union, CPS85)
%@
%We see that there are more non-union women than we would expect just from
%the marginal distribution of union status and gender.

%\Caution{The \function{mosaic()} function has nothing to do with 
%the \pkg{mosaic} package, they just happen to share the same name.}%

%Alternatively, we can send \function{mosaic()} the output of \function{xtabs()}:
%<<rs2-mosaic2,fig.keep="none">>=
%mosaic(xtabs(~ sex + union, CPS85))  # non-whites are more likely to be unionized
%@
%\FoodForThought{Neither \function{mosaic()} nor the similar \function{mosaicplot()}
%are as clever as one could hope.  In particular, without some extra customization,
%both tend to look bad if the levels of the variables have long names.
%\function{mosaic()} plots also always stay square.}


%Alternatively,
%we can send our own hand-made table (although the output isn't quite as nice without some
%extra effort we won't discuss just now):
%<<rs2-mosaic3,fig.width=6,fig.height=2.5>>=
%mosaic(mycrosstable)
%@
%\fi

\begin{problem}
\Rindex{Utilities2}
El conjunto de datos \dataframe{Utilities2} en el paquete mosaic contiene información sobre las cuentas de varias utilidades en una residencia en Minnesota, recolectadas alrededor del tiempo. Puesto que el número de días en el ciclo de facturación varía de mes a mes, variables como \variable{gasbillpay} (\variable{elecbillpday}, etc.) contiene la cuenta del gas (cuenta de electricidad, etc.) dividido por el número de días del ciclo de facturación.
\begin{enumerate}
\item Use la documentación para determinar que contiene la variable \variable{kwH}.
\item
Haga un gráfico de dispersión de \variable{gasbillpday} y \variable{monthsSinceY2K}
<<rs2-gasbill,fig.keep="none", tidy=FALSE>>=
xyplot(gasbillpday ~ monthsSinceY2K, data=Utilities2, 
                     type='l')        # la letra l
@

%\item[]
%What pattern(s) do you see?
\item
¿Qué hace \option{type='l'}? Haga su gráfico sin esto. 
¿Cuál hace más fácil leer la situación?
\item
d)	¿Qué pasa si reemplazamos 
\option{type='l'} 
con \option{type='b'?}
\item
Haga un gráfico de dispersión de \variable{gasbillpday} por mes(\variable{month}). ¿Qué observó?

\item
Haga diagramas de caja uno al lado del otro de \variable{gasbillpday} por mes usando el conjunto de datos \dataframe{Utilities2}. ¿Qué observa?

La primera vez tal vez no le devuelva lo que espera. La razón es que el mes está codificado usando números, entonces \R\ lo trata como un dato numérico. Queremos que lo trate como datos categóricos. Para hacer esto en \R\ use \code{factor(month)} en lugar de \variable{month}. \R\ llama los datos categóricos \term{factor}.

\item
Haga cualquier gráfico que desee usando estos datos. Incluya una copia de su gráfico y una discusión sobre qué se puede aprender del mismo.
\end{enumerate}
\end{problem}

\section{Salvando sus gráficos}

Hay unas cuantas formas de guardar gráficos en RStudio, pero la forma más sencilla es probablemente la siguiente:
\marginnote{Se puede guardar todas estas exportaciones y copiados y pegados si usa \pkg{RMarkdown}

, o \pkg{knitr}/\LaTeX para preparar sus documentos}
\begin{enumerate}
\item
En la viñeta de \tab{plots}, haga click en el botón "Export".
\item
Copie la imagen al clipboard usando el click derecho..
\item
Vaya al documento (e.g. Microsoft Word) y pegue la imagen.
\item
Arregle el temaño y la posición como sea necesario
\end{enumerate}
Otra forma de que un gráfico pueda ser exportado a un documento.

\Rindex{pdf()}%
\R{} brinda una función como \function{pdf()} y \function{png()} que pueden ser utilizadas para guardar gráficos en una variedad de formatos. Vea la documentación de estas funciones para detalles y enlaces para funciones que pueden ser utilizados para guardar gráficos en otros formatos.

\section{\texttt{mplot()}}
\Rindex{mplot()}

La función \function{mplot()} hace una variedad cosas, dependiendo con la información que le demos. 
\Rindex{print()}
\Rindex{plot()}
\Rindex{summary()}
\myindex{generic functions}
\Pointer{\function{mplot()} es una función \emph{genérica}. \R\ incluye muchas funciones genéricas (como \function{print()} y \function{plot()} y \function{summary()}). Estas funciones inspeccionan los objetos pasados como argumentos (al menos el primero) y deciden qué hacer con base en la clase de estos argumentos.}%
%
Cuando \function{mplot()} se le da un conjunto de datos en \RStudio, abre un gráfico interactivo con controles que permiten al usuario seleccionar variables y crear gráficos de diferentes tipos.  

\newpage
\section{Repaso de comandos de \R}

\begin{widestuff}
Aquí hay un pequeño resumen de comandos introducidos en este capítulo.

<<include=FALSE>>=
x <- 1:10
@
\Rindex{tally()}
\Rindex{mean()}
\Rindex{median()}
\Rindex{var()}
\Rindex{sd()}
\Rindex{favstats()}
\Rindex{quantile()}
\Rindex{sum()}
\Rindex{cumsum()}
\Rindex{histogram()}
\Rindex{dotPlot()}
\Rindex{freqpolygon()}
\Rindex{ashplot()}
\Rindex{densityplot()}
\Rindex{qqmath()}
\Rindex{bwplot()}
\Rindex{xyplot()}
\Rindex{bargraph()}
\Rindex{mplot()}
\myindex{quantile-quantile plots|see{\texttt{qqmath}}}
<<tidy=FALSE,results='hide',warning=FALSE, eval=FALSE>>=
require(mosaic)                         # Carga el paquete mosaic
require(mosaicData)                     # carga los datos del paquete

tally( ~ sector, data=CPS85)            # Tabla de frecuencias
tally( ~ sector + race, data=CPS85)     # Tabulación cruzada del 
#sector por etnia   
mean( ~ age, data = HELPrct)            # media de la edad de los participantes
mean( ~ age | sex, data = HELPrct)      # Media de la edad en los participante
#separada por sexo
mean(age ~ sex, data = HELPrct)         # Media de la edad 
#de los sujetos hombres y mujeres
median(x); var(x); sd(x);               # Más resumenes numéricos
quantile(x); sum(x); cumsum(x)          # Aún más resumenes numéricos 
favstats( ~ Sepal.Length, data=iris)    # Cálcula los resúmenes 
#numéricos usuales.

histogram( ~ Sepal.Length | Species, data=iris)   # histogramas 
#(con caracterísitas extra)
dotPlot( ~ Sepal.Length | Species, data=iris)     # Gráficos de puntos 
#para cada especie
freqpolygon( ~ Sepal.Length, groups = Species, data=iris) # Polígonos 
#de frecuencia sobrepuestos
densityplot( ~ Sepal.Length, groups = Species, data=iris) # gráficos 
#de densidad sobrepuestos
qqmath( ~ age | sex, data=CPS85)                          # Gráfico 
#cuantil-cuantil
bwplot(Sepal.Length ~ Species, data = iris)               # Gráficos 
#de caja uno al lado del otro
xyplot(Sepal.Length ~ Sepal.Width | Species, data=iris)   # Gráficos 
#de dispersión uno al lado del otro 
bargraph( ~ sector, data=CPS85)                           #Gráfico de 
#barras
@
<<eval=FALSE>>=
mplot(HELPrct)                         # Gráfico interactivo
@

\end{widestuff}

\section{Ejercicios}

%For these problems, create a single Word document containing all of your work.

\shipoutProblems

<<echo=FALSE,include=FALSE>>=
knitr::opts_chunk$set(fig.path="figures/SBI-") 
knitr::opts_chunk$set(size="small")
knitr::opts_chunk$set(fig.width = 3, fig.height = 2)
require(mosaic)
require(mosaicData)
set.seed(123)
options(digits = 3)
trellis.par.set(theme = col.mosaic())
require(NHANES)
require(Lock5withR)
@

\chapter{Inferencia basada en la simulación}

El abordaje del remuestreo se ha vuelto cada vez más importante en la educación estadística\cite{Tintle:TAS:2015}\cite{Hesterberg:2015}.El paquete \pkg{mosaic} proporciona una herramienta simplificada para respaldar la enseñanza de la inferencia basada en las pruebas de aleatorización y los métodos de bootstrap. Nuestra meta es enfocar la atención en las partes importantes de estas técnicas (e.g, donde la aleatoriedad entra y nos dice cómo usar la distribución resultante) mientras esconde algunos detalles involucrados en crear círculos y acumular valores

\section{Empezando tempranamente}

Una de las ventajas de la inferencia basada en la simulación es que se puede empezar a enseñar la inferencia tempranamente en el curso. La sección 3.1 describe un ejemplo (basado en la dama que probaba té de Fisher) de que la usamos en ocasiones desde el primer día de clases. Los libros de texto que usan abordajes basados en simulaciones también empiezan la discusión del proceso de inferencia inmediatamente, usando otros ejemplos.\cite{Lock5:2012}\cite{Tintle:ISI:2015}. Incluso cuando se enseña un curso más tradicional, la simulación de la dama que prueba té o algún otro ejemplo pueden ser introducidos tempranamente en el curso para ayudar a los estudiantes a entender ideas claves que involucran la prueba de hipótesis y la estimación.

\section{Prueba de hipotesis}

La prueba de hipótesis puede ser pensada como un proceso de 4 pasos:
\begin{enumerate}
\item
  Establecer una hipótesis nula y alternativa
\item
  Calcular un estadístico de prueba
\item
  Determinar un valor p.
\item
  Esbozar una conclusión
\end{enumerate}

En los cursos tradicionales de estadística introductoria, una vez que el flujo de trabajo ha sido dominado, el principal trabajo para los estudiantes es aplicar la fórmula correcta para calcular la prueba estadística estándar en el paso 2 y usar una tabla o la computadora para determinar el valor p basado en la distribución teórica conocida (usualmente aproximada) para el estadístico de prueba sometido a la hipótesis nula.

En un abordaje basado en las simulaciones, los pasos 2 y 3 cambian. En el paso 2 no es requerido que el estadístico de prueba sea normalizado de acuerdo a una distribución conocida. En lugar de esto, el estadístico de prueba es más natural, como la diferencia entre dos medias

\[ 
\overline{y}_1 - \overline{y}_2
\]
puede ser usado en lugar de la prueba t para dos muestras
\[
\frac{ \overline{y}_1 - \overline{y}_2 }
     { \sqrt{ \frac{s_1^2}{n_1} + \frac{s_2^2}{n_2}}} \;.
\]

En el paso 3, usamos la aleatorización para aproximar la distribución muestral de nuestro estadístico de prueba. Nuestro ejemplo de la dama que cata té muestra como esto puede ser hecho desde los principios de la clase, tan temprano como en el primer día.%
\footnote{Ver sección 3.1}  
. Este ejemplo es un poco inusual, después de todo. Como las distribuciones muestrales son tan sencillas, la simulación requiere crear una distribución de aleatorizaciones que es completamente específicada sin datos de referencia: Es una distribución binomial con parámetros determinados por el tamaño de muestra y la hipótesis nula, podemos simular con \code{rflip()}.
%There is only one distribution for a given
%proportion, but there are many distributions that can have 
%a specified mean.  Similarly, if our null hypothesis is that
%two proportions are equal, this doesn't specify what they 
%are equal to.

De manera más típica, vamos a usar la aleatorización para crear nuevos conjuntos de datos simulados, que son como nuestros datos originales en cierta forma, pero hacen la hipótesis nula verdadera. Para cada conjunto de datos simulado, calculamos el estadístico, como lo hicimos con la muestra original. Juntos, esta colección de estadísticos de prueba calculados de muestras simuladas constituye nuestra distribución de aleatorizaciones.

Cuando creamos una distribución de aleatorizaciones, 
vamos a intentar satisfacer 3 principios

\begin{enumerate}
\item Ser consistentes con la hipótesis nula 

Necesitamos simular un mundo en el cual la hipótesis nula es real. 
Si no hacemos esto, no estaremos poniendo a prueba nuestra hipótesis nula.

\item Use los datos en la muestra original

Los datos originales deberían aclarar algunos aspectos de la distribución que no están determinados por la hipótesis nula. Por ejemplo, la hipótesis nula sobre una media no nos dice nada sobre la forma de la distribución de la población, pero los datos nos pueden dar una pista.

\item
Refleje la forma en la que los datos originales fueron recolectados
\end{enumerate}

\subsection{Pruebas de permutaciones usando \code{shuffle()}.}
\myindex{permuation test}%
\Rindex{shuffle()}%
\Rindex{sample()}%
\Rindex{hypothesis test}%

El paquete \pkg{mosaic} proporciona \function{shuffle()} como un sinónimo de \function{sample()}. Cuando se usa sin argumentos adicionales, permuta el primer argumento.
<<>>=
shuffle(1:10)
shuffle(1:10)
@

Aplicar \function{shuffle()} a una variable explicatoria nos permite probar la hipótesis nula de que la variable explicatoria, en efecto, no tiene poder explicatorio. Esta idea se puede usar para probar 
\begin{itemize}
\item
la equivalencia de dos o más proporciones,
\item
la equivalencia de dos o más medias,
\item
si el parámetro de regresión es 0.
\end{itemize}

Por ejemplo, probemos si un hombre joven y una mujer joven tienen el mismo promedio de temperatura corporal, usando el conjunto de datos que contiene temperaturas corporales de 50 estudiantes universitarios, 25 hombres y 25 mujeres.

\medskip

\begin{widestuff}
<<>>=
require(Lock5withR)
inspect(BodyTemp50)
@
\end{widestuff}

\begin{enumerate}
\item Enuncie la hipotesis nula y alternativa.

\begin{itemize}
\item $H_0$: La media de temperatura del cuerpo es la misma para hombres y mujeres
\item $H_a$: La media de temperatura difiere entre hombres y mujeres
\end{itemize}

\item Calcule un estadístico de prueba
\Rindex{diffmean()}%

\medskip

\begin{widestuff}
<<>>=
favstats( BodyTemp ~ Sex, data = BodyTemp50)
T <- diffmean( BodyTemp ~ Sex, data = BodyTemp50); T
@
\end{widestuff}

\item Use la aleatorización para calcular el valor p.
\myindex{p-value}

\medskip

\begin{widestuff}
<<>>=
Temp2.Null <- 
  do(1000) * diffmean( BodyTemp ~ shuffle(Sex), data = BodyTemp50)
histogram( ~ diffmean, data = Temp2.Null, center = 0, v = 0.176)
tally( ~ (diffmean >= T), data = Temp2.Null)
prop( ~ (diffmean >= T), data = Temp2.Null)
@
\end{widestuff}

\item Esboce una conclusión. 

El valor p es grande, entonces estos datos no dan una razón para rechazar la hipótesis de que los estudiantes universitarios, masculinos y femeninos, tienen la misma temperatura corporal.
\end{enumerate}

\subsection{Calculando valores p}

En el ejemplo anterior, no era estrictamente necesario porque el histograma claramente muestra que el estadístico observado (0.176) no es inusual, si la hipótesis nula fuera verdad, entonces estos datos no nos ofrecen ninguna razón para rechazar la hipótesis nula de que los estudiantes universitarios masculinos y femeninos tienen la misma media de temperatura.

Aun así, hay dos asuntos relacionados al cálculo del valor p que queremos agregar en este ejemplo: incluir el estadístico de prueba observado en la distribución nula, y calcular valores p de 2 colas.  
\myindex{p-value!2-sided}%

\Caution[-1cm]{Si está utilizando un libro de texto que cubre el tema de pruebas de aleatorización, revise si incluye el estadístico de prueba calculado de los datos originales en la distribución nula o no.}
Si la hipótesis nula es verdadera, entonces no solo los datos generados aleatoriamente, sino también los datos originales fueron generados en un mundo en el cual la hipótesis nula es verdadera. Entonces tiene sentido agregar el estadístico de prueba a la distribución de aleatorizaciones antes de calcular el valor p. 
Esto tiene dos ventajas. Primero, asegura que nuestro rango de error tipo I no es más grande que el rango nominal. Segundo, evita reportar un valor p de 0, puesto que siempre va habrá al menos un estadístico de prueba tan extremo como el que se generó de los datos originales.

\Caution{Aunque usar 999 o 9999 réplicas puede resultar en valores p que son "número redondeados", hay algún riesgo de que estudiantes usen la distinción del 999 vs 1000 como su forma primaria de decir si está creando una distribución de aleatorizaciones o una de bootstrap.}%
\Rindex{prop1()}%
Para simplificar este cálculo, podemos elegir usar 999 o 9999 replicas en lugar de 1000 o 10000. El paquete mosaic incluye la función prop1() que agrega un conteo adicional al numerador y el denominador, con el propósito de automatizar este tipo de cálculos de valores p. Esto resulta en un valor p (de una cola) un poco más grande

<<>>=
prop1( ~ (diffmean >= T), data = Temp2.Null)
@
\noindent
El único reto para el instructor es decidir cuándo introducir el cambio y si introducir este pequeño cambio va afectar el cálculo del valor p.


Pero necesitamos un valor p de dos colas, dada nuestra hipótesis alternativa. La forma preferida de calcular valores p de dos colas es también la más sencilla: Use el doble del valor p de una cola

<<>>=
2 * prop1( ~ (diffmean >= T), data = Temp2.Null)
@

Un abordaje alternativo en ocasiones visto, agregaría la proporción de la distribución de aleatorizaciones que está debajo de -T = -0.176. Para una distribución de aleatorizaciones simétrica, esto debería dar un resultado similar, pero esto no se lleva a cabo cuando la distribución de aleatorizaciones está muy distorsionada, es un poco más difícil de calcular, y no es una transformación invariante, entonces las pruebas que son equivalentes como pruebas de una cola, pueden no resultar equivalentes en pruebas de dos colas. 
Parece que no hay razón para introducir este método a los estudiantes. 
\TeachingTip{Esta alternativa puede ser cubierta en el libro de texto que esté utilizando, entonces puede ser que sus estudiantes la usen, aunque no la haya enseñado}

\subsection{Algunos ejemplos adicionales}

La técnica del "shuffling" con una variable explicatoria puede ser aplicado a un amplio rango de situaciones. Las siguientes plantillas ilustran la similitud de estos



\Rindex{diffprop()}%
\Rindex{diffmean()}%
\Rindex{chisq()}%
\Rindex{tally()}%
\Rindex{lm()}%

\medskip

\begin{widestuff}
<<eval = FALSE>>=
Two.Proportions <- do(999) * diffprop(y ~ shuffle(x),     data = Data)
Two.Means       <- do(999) * diffmean(y ~ shuffle(x),     data = Data)
Linear.model    <- do(999) *       lm(y ~ shuffle(x) + a, data = Data)
Two.Way.Table   <- do(999) *    chisq(y ~ shuffle(x),     data = Data)
@
\end{widestuff}

\Note[1.1cm]{La función \function{chisq()} calcula un estadístico ji-cuadrado tanto de la fórmula como del conjunto de datos, de una tabla producida por \function{tally()}, o de un objeto producido por \function{chisq.test()}.}


Como ejemplo, consideremos la proporción de sujetos en el Health Evaluation and Linkage to Primary Care que fueron admitidos para el programa de abuso de sustancias: alcohol, cocaína y heroína. Nos gustaría saber si hay evidencia de que estas proporciones difieren para hombres y mujeres. En nuestro conjunto de datos, observamos diferencias modestas

<<>>=
tally( substance ~ sex, data = HELPrct, 
       format="prop", margins = TRUE)
@
\noindent
¿Pueden esas diferencias ser atribuidas a la suerte? ¿O los resultados nos dan evidencia confiable que la droga de escogencia varía (un poco) entre hombres y mujeres?

Podemos simular en un mundo en el cual las proporciones varían solamente por la variabilidad del muestreo aleatorio usando \function{shuffle()} para permutar la etiqueta del sexo (o equivalentemente la de la sustancia)


\medskip

\begin{widestuff}
<<>>=
T <- chisq(substance ~ shuffle(sex), data = HELPrct); T  # test statistic
Substance.Null <- 
  do(999) * chisq(substance ~ shuffle(sex), data = HELPrct)
histogram( ~ X.squared, data = Substance.Null, v = T, width = 0.25)
prop1( ~(X.squared >= T), data = Substance.Null)
@
\end{widestuff}
\noindent


El histograma y el valor p sugieren que las diferencias entre hombres y mujeres no son estadísticamente significativos.


\subsection{Probando una sola media}

\Note{De alguna forma, esta es la hipótesis que 
fue más difícil de manejar con nuestro sistema. Vea más adelante, 
por una razón no nos molestó mucho.}%
Un problema con nuestro sistema es la prueba para una sola media. Ilustremos un una prueba con $H_0: \mu = 98.6$ usando una muestra de 50 temperaturas corporales. Probar la hipótesis nula de la forma
\begin{itemize}
\item
  $H_0$: $\mu = \mu_0$ 
\end{itemize}
presenta un caso especial. 
Contrario a los ejemplos anteriores a este, no hay variables explicatorias qué mezclar. Contrario a la prueba para una única proporción, la hipótesis nula no viene completamente a especificar la distribución de muestreo.

\Note{Muchos libros usan $\overline{X}$ en lugar de $\overline{Y}$.}%
At least there is an obvious candidate for a test statistic: the sample mean, 
$\overline y$.

\Rindex{BodyTemp50}%
\myindex{test statistic}%
<<>>=
mean( ~ BodyTemp, data = BodyTemp50)
@

Este estadístico de prueba es fácilmente aplicado a cualquier conjunto de datos, solo necesitamos una forma de generar conjuntos de datos aleatorios en los cuales la hipótesis nula es verdadera. Como se menciona anteriormente, no hay una variable explicatoria que se pueda mezclar. Si mezclamos \variable{BodyTemp} (o todo el conjunto de datos), vamos a obtener la misma media siempre, puesto que la media no depende del orden.

En lugar de esto, muestreamos con reemplazo. 
La función \code{resample()} nos ayuda en esto.
<<>>=
resample(1:10)   # notice the duplicates
@
Podemos re-muestrear variables individuales o toda la tabla de datos. (Puesto que sólo hay una variable en este análisis, los resultados van a ser los mismos de todas formas.)

<<>>=
# Esto no funciona:
Temp0.Null <- 
  do(999) * mean( ~ BodyTemp, data = resample(BodyTemp50))
@
\noindent
Desafortunadamente, \code{Temp0.Null} no es una distribución de aleatorizaciones. Inspeccionando el histograma se puede ver que la distribución no está centrada en 98.6, entonces no estamos simulando un universo donde la hipótesis nula es verdadera.
<<>>=
histogram( ~mean, data = Temp0.Null)
@
\noindent

En cambio, está centrada en la media de nuestra muestra original, 98.26. Podemos cambiar la distribución con 98.6 - 98.26 = 0.34. Esto puede darnos de resultado una distribución que tiene la misma forma que la de nuestros datos con una media de 98.6, como la hipótesis nula exige.

\smallskip

\begin{widestuff}
<<>>=
Temp1.Null <- do(9999) * 
  mean( ~ BodyTemp + (98.6 - 98.26), data = resample(BodyTemp50))
histogram( ~ mean, data = Temp1.Null, v = 98.26, center = 98.6)
@

\end{widestuff}
Como antes, podemos estimar el valor p tabulando que tan seguido vemos un valor como 98.26.
<<cache = FALSE>>=
2 * prop1( ~ (mean <= 98.26), data = Temp1.Null)
@
\noindent
\Note{Usamos más replicas en este ejemplo para darnos un mejor 
estimado de este valor p pequeño.}%
En este caso, el valor p es bastante pequeño --
pareciera que 98.6 no es la media de la temperatura corporal.

De todas las distribuciones de aleatorizaciones, las distribuciones de aleatorizaciones usadas para probar hipótesis sobre un media son las más complicadas de crear, por el cambio que es necesario para centrar la distribución y el uso de \function{resample()} (que puede causar confusión con las distribuciones de bootstrap). Afortunadamente, crear un intervalo de confianza de una distribución de bootstrap en estas situaciones es muy directo, y generalmente preferimos intervalos de confianza que valores p en esta situación.


\section{El Bootstrap}

El método de bootstrap es utilizado (primariamente) para crear intervalos de confianza. La idea fundamental es bastante simple, además ayuda a reforzar ideas importante sobre lo que es un intervalo de confianza.

\subsection{La idea detrás del Bootstrap}
\myindex{bootstrap}%

\Caution{Hay métodos más complicados para calcular intervalos de confianza de bootstrap que tienen un mejor desempeño. Nosotros aquí introducimos dos métodos sencillos aquí. En ocasiones vamos a volver a hablar en el curso del libro sobre los intervalos-t de bootstrap.}
Suponga que queremos estimar la media de la temperatura usando el conjunto de datos de \dataframe{BodyTemp50}. Es suficientemente simple calcular la media de nuestros datos.

<<>>=
mean( ~ BodyTemp, data = BodyTemp50)
@
\noindent
Lo que falta, es sentido de que tan precisa es la estimación. 
La forma más común de presentar esta información es un intervalo de confianza.

Si tuviéramos acceso a toda la población, podríamos generar muchas muestras aleatorias y observar cuanta variabilidad hay estimada de muestra a muestra (ver sección 5.8). En la práctica, nunca vamos a tener acceso a una población total (de lo contrario no necesitaríamos hacer estimaciones). La idea clave del bootstrap es tratar nuestras muestras como representaciones aproximadas de la población y generar una distribución muestral aproximada por medio del muestreo con reemplazo de nuestra muestra. La forma de la distribución de bootstrap indica qué tan precisa es \emph{nuestra estimación}.
\Note{Podemos usar métodos de bootstrap para estimar el error en nuestra estimación también}%

La forma de nuestra distribución de bootstrap dice que tan precisa es nuestra estimación.

Antes de proceder, hay algunas cosas importantes que hay que resaltar del proceso.
\begin{enumerate}
\item El re-muestreo no da una mejor estimación

El re-muestreo es solamente usado para estimar una \emph{variabilidad} de muestra a muestra, no es un intento de mejorar el estimado. Si intentáramos mejorar la estimación usando las muestras de bootstrap, estaríamos simplemente haciéndola peor produciendo estimados de nuestro estimado y esencialmente doblando el error en la estimación.

\item
Re-muestrear funciona mejor con muestras grandes que con pequeñas.

Las muestras pequeñas representan la población de forma poco verosímil. Si bien los métodos de re-muestreo nos pueden brindar métodos que funcionan tan bien como los tradicionales en situaciones estándar, y además pueden ser aplicados en un amplio rango de situaciones sin desempeño menor; esto no cambia el principio fundamental de tener tamaños de muestra suficiente.

\item 
Los dos métodos de bootstrap que presentaremos fueron elegidos por la simpleza, no por su desempeño.

El valor que se encontró al introducir el bootstrap en cursos introductorios es pedagógico, no científica. El intervalo de percentil y error estándar son introducidos posteriormente y son accesibles a los estudiantes, además de que pueden ser aplicados a una amplia gama de situaciones. Pero estas no van a la vanguardia. En la sección 5.7 vamos a discutir un poco el intervalo t de bootstrap, un método de bootstrap más preciso. Otros métodos, como el BCa (error corregido y acelerado) o ABC (confianza aproximada de bootstrap) también mejoran el método del percentil y del error estándar, pero están fuera del alcance de la mayoría de cursos introductorios.

\end{enumerate}

\Rindex{resample}%
\Rindex{boot}%
Paquetes como \pkg{resample} y \pkg{boot} proporcionan funciones 
para calcular intervalos usando métodos más sofisticados.

\subsection{Intervalos de confianza de bootstrap para una media}

\myindex{confidence interval}%
Crear una distribución de aleatorizaciones para probar una hipótesis para 
una media tenía algunos retos. Afortunadamente, un intervalo de confianza 
es usualmente preferido en estas situaciones, y crear distribuciones de 
bootstrap para una media es muy directo: 
Simplemente calculamos la media de la temperatura corporal de muchas 
versiones remuestreadas de nuestros datos originales

<<>>=
Temp.Boot <- 
  do(1000) * mean( ~BodyTemp, data = resample(BodyTemp50))
@
\noindent
Cuando es aplicado a todo el conjunto de datos, la función \function{resample()} 
muestrea con reemplazo para producir nuevos conjuntos de datos, con el mismo 
número de filas del original pero con algunas duplicadas y otras que no aparecen.

\Caution[-2cm]{En situaciones para nada deseables, quizás tengamos que ajustar el error 
o usar métodos más sofisticados.Es bueno para los estudiantes tener el hábito de 
revisar estas características de la distribución de bootstrap antes de usar los 
métodos que presentamos en esta sección.}
Idealmente, la distribución de bootstrap tiene que ser unimodal, aproximadamente simétrica, y centrada en el estimado original.

<<>>=
mean( ~ BodyTemp, data = BodyTemp50)
mean( ~ mean, data = Temp.Boot)
histogram( ~ mean, data = Temp.Boot, nint = 25,
           v = mean( ~ BodyTemp, data = BodyTemp50),
           c = mean( ~ BodyTemp, data = BodyTemp50)
           )
@

Para calcular un intervalo de confianza del percentil al 95\%, podemos determinar el rango central del 95\% de la distribución de bootstrap. La función \function{cdata()} automatiza este cálculo.
\Rindex{cdata()}%
<<>>=
cdata( ~ mean, data = Temp.Boot, p = 0.95)
@
\noindent
\Rindex{qdata()}%
Alternativamente, \function{qdata()} puede ser utilizado para obtener los extremos izquierdos y derechos separadamente (o para un intervalo de confianza de solamente una cola).

<<>>=
qdata( ~ mean, data = Temp.Boot, p = 0.025)
qdata( ~ mean, data = Temp.Boot, p = 0.975)
@

Un segundo método simple para calcular un intervalo de confianza de una distribución de bootstrap incluye utilizar la distribución de bootstrap para estimar el error estándar.
\myindex{standard error}
<<>>=
SE <- sd( ~ mean, data = Temp.Boot); SE
estimate <- mean( ~ BodyTemp, data = BodyTemp50) 
estimate
estimate + c(-1,1) * 2 * SE
@

Este método no se desempeña tan bien como el método del percentil, pero puede servir como un buen puente para los intervalos de confianza basados en la fórmula, incluidos usualmente en cursos que se enfocan en métodos basados en simulación. Como reemplazar la constante 2 con un valor apropiado crea intervalos de confianza más precisos o permite diferentes niveles es cosa de un poco de sutileza. El método más simple es usar los cuantiles de una distribución normal. Reemplazar la distribución con una distribución t apropiada va ensanchar los intervalos y puede mejorar la cobertura, pero la distribución t es la correcta en pocos casos - como cuando estimamos la media de una población normal - y puede cubrir mal cuando la población es distorsionada. \cite{Hesterberg:2015}  

Como cada uno de estos métodos produce un intervalo de confianza que depende únicamente de la distribución de los estimados calculados de re-muestras, se pueden implementar fácilmente en una amplia variedad de situaciones. Calcular cualquiera de estos intervalos de confianza simples de distribuciones bootstrap puede ser automatizado usando una extensión de \code{confint()}

\medskip

\begin{widestuff}
<<>>=
confint(Temp.Boot, method = c("percentile", "stderr"))
@
\end{widestuff}

Todos lo que se muestra, es la generación de la distribución del bootstrap.

\subsection{Intervalos de confianza de bootstrap para la diferencia de medias}

Si estamos interesados en un intervalo de confianza para la diferencia en medias de grupos, podemos usar \code{resample()} y \code{do()} para generar distribuciones de bootstrap en una de las dos formas.

\medskip

\begin{widestuff}
<<>>=
Temp.Boot2a <- 
  do(1000) * diffmean(age ~ sex, data = resample(HELPrct))
Temp.Boot2b <- 
  do(1000) * diffmean(age ~ sex, data = resample(HELPrct, groups = sex))
@
\end{widestuff}
\Note{Es útil adoptar una convención en cuanto al nombramiento de la aleatorización y las distribuciones de bootstrap. Los nombres deben reflejar los datos que están siendo utilizados y si la distribución es de bootstrap o de aleatorizaciones. Usualmente usamos \code{.Random} o \code{.Null} para indicar la distribución de aleatorizaciones y \code{.Boot} para indicar las de bootstrap.}
\noindent
En el segundo ejemplo, el re-muestreo sucede entre los grupos de sexo, de tal forma que los conteos marginales para cada sexo se mantengan fijados. Esto puede ser especialmente importante si uno de los grupos es pequeño, puesto que de otra forma los re-muestreos podrían no incluir ninguna observación en el grupo

<<include=FALSE>>=
set.seed(123456)
@
<<>>=
favstats(age ~ sex, data = HELPrct)
D <- diffmean( age ~ sex, data = HELPrct); D
favstats(age ~ sex, data = resample(HELPrct))
favstats(age ~ sex, data = resample(HELPrct, groups = sex))
@

De aquí, el cálculo de los intervalos de confianza procede como antes.

\Note{Inspeccionar visualmente la distribución de bootstrap por irregularidades y errores es un paso importante para asegurarse que el intervalo del percentil no está siendo aplicado en una situación en la cual se puede desempeñar pobremente.}
<<>>=
histogram( ~ diffmean, data = Temp.Boot2b, v = D)
qqmath( ~ diffmean, data = Temp.Boot2b)
cdata( ~ diffmean, p = 0.95, data = Temp.Boot2b)
@

Alternativamente, podemos calcular un intervalo de confianza basado en un estimado del bootstrap del error estándar.
<<>>=
SE <- sd( ~ diffmean, data = Temp.Boot2b); SE
D + c(-1,1) * 2 * SE
@

% \noindent
% The primary pedagogical value of the bootstrap standard error approach is its close
% connection to the standard formula-based confidence interval methods.
% How to replace the constant 2 with an appropriate value to create more accurate intervals
% or to allow for different confidence levels is a matter of some subtlety
% \cite{Hesterberg:2015}.  The simplest method is to use quantiles 
% of a normal distribution, but this will undercover. Replacing the normal distribution
% with an appropriate t-distribution will widen intervals and can improve coverage, but 
% the t-distribution is only correct in a few cases -- such as when estimating the mean
% of a normal population -- and can perform badly when the population is skewed.
% See Section~\ref{sec:improved-cis} for more on this.


\noindent
\Rindex{confint()}%
Ambos intervalos pueden ser calculados usando \code{confint()}, si preferimos.
<<>>=
confint(Temp.Boot2b, method = c("percentile", "stderr"))
@

\subsection{Comparación de distribuciones bootstrap}

Para ilustrar la similitud entre comandos usados para crear distribuciones 
bootstrap, aquí presentamos cinco ejemplos que pueden aparecer 
en cursos introductorios.
\medskip

\begin{widestuff}
<<eval = FALSE>>=
One.Proportion  <- do(1000) *     prop(   ~ x, data = resample(Data))
Two.Proportions <- do(1000) * diffprop( y ~ x, data = resample(Data, groups = x))
One.Mean        <- do(1000) *     mean(   ~ x, data = resample(Data))
Two.Means       <- do(1000) * diffmean( y ~ x, data = resample(Data, groups = x))
Correlation     <- do(1000) *      cor( y ~ x, data = resample(Data))
@
\end{widestuff}

%In the next section we discuss how to extend this to regression models.

\section{Remuestreo para una regresión}

Hay al menos dos formas que podemos considerar para crear una distribución de bootstrap para un modelo lineal. Podemos facilmente ajustar un modelo lineal de un conjunto de datos re-muestreado. Pero en algunas situaciones esto puede tener efectos indeseables. Por ejemplo, observaciones de influencia pueden aparecer duplicadas en algunas re-muestras y desaparecer en otras.


Otra opción es usar el "re-muestreo residual". En el re-muestreo residual, el nuevo conjunto de datos tiene todos los valores predichos de los datos originales y una nueva respuesta se crea agregando al modelo ajustado los residuales re-muestreados.


Los dos métodos son simples de implementar; podemos de 
igual forma re-muestrear los datos o el modelo por sí mismo.


\medskip

\Rindex{relm()}%
\Rindex{resample()}%
\begin{widestuff}
<<>>=
mod <- lm( length ~ width + sex, data = KidsFeet)         # modelo original
do(1) * lm(length ~ width + sex, data=KidsFeet)          # Ver como do() lo trata
do(2) * lm( length ~ width + sex, data = resample(KidsFeet))  # datos remuestreados
do(2) * lm( length ~ width + sex, data = resample(mod))       # residuales remuestrados
do(2) * relm(mod)                 # remuestreo residual abreviado
@
\end{widestuff}

De aquí, esto va dirigido a crear intervalos de confianza para la pendiente (o intercepto, o cualquier coeficiente) en un modelo lineal.
<<>>=
Kids.Boot <- do(1000) * relm(mod)
cdata( ~ width, data = Kids.Boot, p = 0.95)
confint( Kids.Boot, parm = "width")
@


\section{¿Qué va primero: valores p o intervalos?}

TEsto es tema de discusión entre los instructores y autores de libros. Los dos libros de estadística introductoria dan respuestas diferentes. 
Uno\cite{Tintle:ISI:2015} introduce primero la prueba de hipotesis, el otro\cite{Lock5:2012} empieza con los intervalos de confianza de bootstrap.  
TEstos libros difieren también de algunos otros también. Permanece pendiente si la mejor práctica emerge de ciertos problemas o seguirá siendo de preferencia personal. Esto no es diferente al viejo debate de si se debe empezar por los datos cuantitativos o categóricos - otra forma en la que estos dos libros basados en simulación divergen.

\section{Lidiando con la variabilidad de Monte Carlo}

Puesto que la aleatorización y las distribuciones de bootstrap envuelven componentes aleatorios, valores p e intervalos de confianza calculados de los mismos datos van a variar. Para los estudiantes (y graduados), esto puede ser desconcertante porque no hay una respuesta "correcta".

La cantidad de variabilidad de Monte Carlo depende del número de réplicas usadas para crear las distribuciones de aleatorizaciones o bootstrap. Y los estudiantes necesitan alguna guía en cuantas replicas usar. Es importante que no usen muy pocas, esto introduciría mucho ruido al valor p y el cálculo del intervalo de confianza. Pero cada replica toma tiempo, y la ganancia marginal para cada replica adicional decrece conforme el número de réplicas incrementa. No tiene mucho sentido usar millones de réplicas (a menos que la meta sea estimar valores p muy pequeños). Generalmente usamos aproximadamente 1000 por rutina o por trabajo preliminar, incrementamos esto a 10000 cuando queremos reducir los efectos de la variabilidad de Monte Carlo..  

En condiciones de laboratorio, puede ser instructivo tener que comparar los valores p o los intervalos de confianza usando 1000 y 10000 réplicas. De forma alternativa, el instructor puede generar varios valores p o intervalos de confianza para ilustrar el mismo principio.


\section{Mejores intervalos de confianza}
\label{sec:improved-cis}%

\myindex{bootstrap-t}
Los intervalos de confianza del percentil y del "error estándar de t con bootstrap" pueden ser mejorados en un amplio número de maneras. En un primer curso, generalmente hacemos un poco más que mencionar este hecho, y alentamos a los estudiantes a inspeccionar la forma de la distribución de bootstrap para observar indicadores de posibles problemas con el método del percentil.

Una mejoría que puede ser explicada a los estudiantes en un curso que combina los abordajes tanto de fórmula como de simulación es el intervalo de t de bootstrap. En lugar de intentar determinar la mejor cantidad de grados de libertad para la distribución t de student, la t de bootstrap aproxima la verdadera distribución de
$$
t = \frac{\hat{\theta} - \theta}{SE}
$$
usando la distribución de bootstrap de
$$
t^* = \frac{\hat{\theta}^* - \hat{\theta}}{SE^*} \; ,
$$
Donde $\hat{\theta}^*$ y $SE^*$ son el estimado y el error estándar estimado calculado de cada distribución de bootstrap. Implementar el intervalo t de bootstrap requiere o un nivel extra de esbozo conceptual o muchos más cálculos para determinar los valores de $SE^*$. Si la fórmula de error estándar existe  (e.g., $SE = s/\sqrt{n}$), esto puede ser aplicado a cada muestra de bootstrap simultáneo al estimador. Una alternativa es iterar el proceso de bootstrap (re-muestreando de cada re-muestreo) para estimar el SE. Puesto que el error estándar es más fácil de estimar que el intervalo de confianza, una menor cantidad de re-muestreos son requeridos (por re-muestreo) en un segundo nivel; sin embargo, el trabajo computacional adicional es significativo.

El paquete \pkg{mosaic} no intenta brindar una estructura general para la t de bootstrap u otros métodos de bootstrap
Paquetes como \pkg{resample}\cite{resample}  y \pkg{boot}\cite{boot,boot-book}
son más apropiados para situaciones en las cuales la velocidad y la precisión son de máxima importancia. Sin embargo, el intervalo de confianza de la t de bootstrap puede ser calculado usando \function{confint()}, \function{do()} y \function{favstats()} en caso de estimar una sola media o la diferencia entre estas medias.

En el ejemplo anterior, analizamos un conjunto de datos del paquete \pkg{resample}. El conjunto de datos \dataframe{Verizon} contiene tiempos de reparación para clientes de los servicios en CLEC(competitiva) e ILEC(obligatorio).

\medskip

\begin{widestuff}
<<>>=
# El paquete resample tiene problemas de nombres con mosaic
#Entonces sólo cargamos los datos, no el paquete

data(Verizon, package = "resample")
ILEC <- Verizon %>% filter(Group == "ILEC")       
favstats( ~ Time, groups = Group, data = Verizon)
 ashplot( ~ Time, groups = Group, data = Verizon, 
          auto.key = TRUE, width = 20)
@
\end{widestuff}

\noindent
La irregularidad de las distribuciones en el tiempo de reparación y los tamaños de muestra no equivalentes resalta las diferencias entre la t de bootstrap y otros métodos más simples.

<<>>=
BootT1 <- 
   do(1000) * favstats(~ Time, data = resample(ILEC))
confint(BootT1, method = "boot")
BootT2 <- 
  do(1000) * favstats( ~ Time, groups = Group, 
                       data = resample(Verizon, groups = Group))
confint(BootT2, method = "boot")
@
\noindent
Esto también se puede lograr manualmente, aunque los cálculos son un poco más interesantes para el caso de 2 muestras. Aquí están los cálculos manuales para el caso de 1 muestra:
<<fig.keep = 'high', fig=TRUE>>=
estimate <- mean( ~ Time, data = ILEC) 
estimate
SE <- sd( ~ mean, data = BootT1); SE
BootT1a <- 
  BootT1 %>% 
  mutate( T = (mean - mean(mean)) / (sd/sqrt(n)))
q <- quantile(~ T, p = c(0.975, 0.025), data = BootT1a) 
q
estimate - q * SE
densityplot( ~ T, data = BootT1a)
plotDist("norm", add = TRUE, col="gray50")
@

Para una comparación, aquí hay intervalos producidos por el métodos de \code{t.test} y el método del percentil.

\medskip

\begin{widestuff}
<<>>=
confint(t.test( ~ Time, data = ILEC))
BootT1b <- 
  do(1000) * mean( ~ Time, data = resample(ILEC))
confint(BootT1b, method = "perc")
@
\end{widestuff}

\begin{widestuff}
<<>>=
confint(t.test(Time ~ Group, data = Verizon))
BootT2b <- 
  do(1000) * diffmean(Time ~ Group, data = resample(Verizon, groups = Group))
confint(BootT2b, method = "perc")
@
\end{widestuff}

\noindent
En una situación como esta, los intervalos producidos por \code{t.test()} son más angostos, haga lo mínimo para compensar por las irregularidades, encubra y evite más seguido una dirección que la otra.

Aunque estos métodos no son presentados a los estudiantes, es bueno para los instructores estar por lo menos de cierta forma familiarizados con los asuntos envueltos en esto y algunos de los métodos que han sido desarrollados para manejarlos.\cite{Hesterberg:2015}
% for a more 
% thorough discussion of what instructors should know about the bootstrap. 

\section{Simulando distribuciones muestrales}
\label{sec:sampling-dists}%
\myindex{sampling distribution}%
Concluimos de este capítulo que con un uso más de \code{sample()}. Si usamos el los datos que tenemos como una población, \code{sample()} puede ser usado para generar muestras aleatorias de un tamaño específico para ilustrar la idea de una distribución de muestreo. Podemos usar esto para ilustrar las distribuciones de muestreo de una media muestral, por ejemplo.

\Rindex{NHANES}%
Para el ejemplo vamos a usar los datos de \dataframe{NHANES}. Estos datos han sido ajustados para reflejar las ponderaciones muestrales usadas en las encuestas del American National Health and Nutrition Examination y es una buena aproximación de una muestra aleatoria simple de tamaño 10000 de la población de Estados Unidos. Para propósitos del ejemplo, vamos a tratar esto como una población total y considerar las muestras generadas de él, enfocándonos (en el momento) en la variable Age.

<<>>=
require(NHANES)
mean( ~ Age, data = NHANES)           # population mean
@

Vamos a considerar muestras de tamaños 50 y 200. Esto puede ser usado para demostrar el rol del tamaño de muestra en las distribuciones muestrales.

\medskip

\begin{widestuff}
<<>>=
mean( ~ Age, data = sample(NHANES, 50))  # media de una muestra
mean( ~ Age, data = sample(NHANES, 50))  # mean of another sample
@
\end{widestuff}

\begin{widestuff}
<<>>=
# Usamos bind_rows() para combinar dos distribuciones muestrales
# (con diferentes tamaños de muestra) en un único conjunto de datos para
# hacer los resúmenes gráficos y numéricos más sencillos.
SamplingDist <-
  bind_rows(
    do(2000) * c(mean = mean( ~ Age, data = sample(NHANES, 50)), n= 50),
    do(2000) * c(mean = mean( ~ Age, data = sample(NHANES, 200)), n= 200)
  )
@
\end{widestuff}

\begin{widestuff}
<<>>=
mean( mean ~ n, data = SamplingDist)    # Media de la distribución muestral
sd( mean ~ n, data = SamplingDist)      # Desviación estándar de la 
#distribución de muestreo
@
\end{widestuff}

\begin{widestuff}
<<>>=
sd( ~ Age, data = NHANES) / c("50" = sqrt(50), "200" = sqrt(200))  
#SE de la fórmula
histogram( ~ mean | factor(n), data = SamplingDist, 
           nint = 50, density = TRUE)
@
\end{widestuff}


Un abordaje similar puede ser usado para crear distribuciones de muestreo en otro tipo de situaciones


<<echo=FALSE,include=FALSE>>=
opts_chunk$set( fig.path="figures/RForStudents-" ) 
set.seed(123)
@
\chapter{Lo que los estudiantes necesitan saber de 
R y cómo enseñarlo}
\label{chap:RForStudents}
En el capítulo 2, damos una pequeña orientación en el IDE \Rstudio y vemos qué pasa en sus viñetas y paneles
\Pointer{Asegúrese de ojear \emph{Una guía de estudiantes para R}, también. Este pequeño libro contiene un resumen corto de todos los comandos necesarios para el análisis estadístico típicamente visto en los dos primeros cursos de estadística.}%
. En el capítulo 4, mostramos como hacer uso de una notación común de resúmenes gráficos, resúmenes numéricos, y modelaje. En este capítulo cubrimos algunos detalles adicionales que son importantes para que los estudiantes sepan sobre el lenguaje de \R.

\section{Dos preguntas}
\myindex{questions!two}
\myindex{template!the}

Cuando introdujimos la notación de fórmula en el capítulo 4, presentamos dos preguntas importantes que se deben hacer antes de construir un comando de \R. Estas preguntas son útiles en contextos más allá de la notación o plantilla de fórmula, y de hecho para otros sistemas computacionales más allá de \R, entonces los repetimos aquí.

\TeachingTip[-1in]{Cuando los estudiantes tienen dificultad logrando una tarea en \R, asegúrese que pueden responder estas preguntas antes de mostrarles qué hacer. Si no pueden contestarlas, entonces el problema no es primariamente con \R. Si hace esto consistentemente, eventualmente, va encontrar a sus estudiantes presentado sus preguntas de \R contestando estas dos preguntas y después preguntando "¿Entonces, cómo logro que R haga eso?" Probablemente después de contestar esas dos preguntas, ya van a saber cómo hacer que \R haga lo que quieren - a menos que estén preguntando la funcionalidad de algo que aún no haya presentado.}
%
\begin{enumerate}
	\item ¿Qué quiere que haga \R?  

Esto usualmente va determinar cuál función de \R\ usar.

	\item ¿Qué tiene que saber R para hacerlo?   

		Esto va determinar las entradas de la función.   
\end{enumerate}

Cuando sus estudiantes formulen sus preguntas sobre \R{} en lo que quieren que \R{} haga y qué necesita saber \R{} para hacerlo, entonces sabrá que estas preguntas fueron interiorizadas.

\newpage

\section{Cuatro cosas que saber sobre \R}

Como en casi todos los lenguajes computacionales, \R\ debe usarse en sus términos. \R\ no aprende la personalidad y el estilo de sus usuarios. Llevarse con \R\ es mucho más sencillo si usted tiene en mente (y le recuerda a sus estudiantes) algunas características claves del lenguaje \R.

\begin{enumerate}
\item \R\ es sensible a casos 
\TeachingTip[-1cm]{A algunos estudiantes se les 
dificulta entender la importancia de las mayúsculas. 
Así que tal vez tenga que recordarlo unas cuantas veces más.} 

Si usted pone una mayúscula de más en algo en R no va hacer lo que usted deseaba. 
Desafortunadamente no hay una convención sobre como las mayúsculas deben ser usadas, 
entonces debe ponerle atención cuando se encuentre con nuevas funciones y conjuntos de datos

\item 
Las funciones de \R\ usan la siguiente sintaxis:
<<label="rs-function-syntax",eval=FALSE>>=
functionname( argument1, argument2, ... )
@
\vspace{-5mm}
\TeachingTip{Introduzca las funciones enfatizando las preguntas \emph{¿Qué queremos que haga la computadora?} y \emph{¿Qué información necesita la computadora para hacer esto?} La respuesta a la primera pregunta determina qué función usar. La respuesta a la segunda determina cuáles argumentos deben especificarse.
}%
\begin{itemize}
\item Los argumentos están \underline{siempre} rodeados por \emph{paréntesis (redondos)} y \emph{separados por comas}.

Algunas funciones (como \function{data()}) no requieren argumentos, pero igual necesitan paréntesis.

\item
Si escribe el nombre de una función sin paréntesis, va ver el \emph{código} para esa función (esto generalmente no es lo que se quiere, a menos que sea curioso y quiera saber cómo es implementado).
\end{itemize}
\item
El relleno de línea de código y las flechas pueden mejorar la velocidad de la escritura y la precisión.

Si empieza un comando y después le da la tecla enter, \R\ y \RStudio le van a presentar una lista de posibles formas de completar el comando. Si oprime ENTER después de abrir un paréntesis de una función, \RStudio le va desplegar la lista de argumentos que espera. 

Las flechas lo pueden ayudar a encontrar comandos pasados cuando se trabaja en la consola.
\item
Si ve una entrada con \code{+}, significa que \R está pidiendo más entrada o código.

\Caution{Sus estudiantes en ocasiones van a encontrarse en un 
hueco sintáctico del que no pueden salir. 
Enséñeles a presiones la tecla ESC a tiempo.}%
Esto puede significar que hace falta cerrar el paréntesis o que se ha hecho algún error de sintaxis. Si tuvo algún problema y solo quiere la salida normal, presione la tecla de escape para empezar el comando de nuevo.
\end{enumerate}

\section{Instalando y usando paquetes}
\label{sec:installingPackages}
\myindex{package!installing}
\myindex{package!installing|seealso{\texttt{install.packages()}}}
\myindex{package!installing|seealso{\texttt{install_github()}}}

\TeachingTip{Si ajusta \RStudio con el servidor, puede instalar todos los paquetes que quiera usar. Puede incluso configurar el servidor para auto cargar paquetes que usa frecuentemente. Los estudiantes que usen \R\ en sus propias computadoras van a necesitar saber cómo instalar y cargar estos paquetes.}

\R\ es un software libre. Su desarrollo es respaldado por un grupo base de desarrolladores y una gran comunidad de usuarios. Una forma mediante la cual los usuarios apoyan \R\ es compartiendo paquetes que contienen datos y funciones para una amplia variedad de tareas. Como instructor, va querer elegir una serie de paquetes que apoyen la forma en la que da su curso.

%\subsection{Installing packages from \cran}
\myindex{CRAN (Comprehensive R Archive Network}
Si necesita instalar un paquete, es muy probable que esté en CRAN, the Comprehensive R Archive Network. Antes de usar un paquete, lo debe \term{instalar} (una vez por computadora o cuenta de usuario) y \term{cargar} (una vez por sesión de \R). 
\myindex{package!loading}
\myindex{package!loading|seealso{\texttt{require()}}}
\myindex{package!loading|seealso{\texttt{library()}}}
El proceso de instalación descarga el paquete y prepara para compilar (si es necesario) y pone los componentes en la dirección adecuada para uso futuro. Cargar hace los paquetes previamente instalados disponibles para usar en la sesión de \R.

\Rindex{install.packages()}%
\Rindex{require()}%
\Rindex{library()}%

Por ejemplo, para usar el paquete mosaic, primero debemos instalarlo:
<<eval=FALSE,tidy=FALSE>>=
install.packages("mosaic") 
# Obtener el paquete del CRAN 
@
Una vez que el paquete ha sido instalado, debe ser \emph{cargado} para que esté disponible en la sesión o creación del documento:
\TeachingTip[-2.5cm]{Usar \function{library} es más común en estas situaciones, pero nos dimos cuenta que los estudiantes recuerdan mejor la palabra \function{require()}. Para su propósito, ambos hacen esencialmente lo mismo. La mayor diferencia es como responde cuando un paquete no puede cargarse (usualmente porque este no está instalado). require() genera un mensaje de alerta y devuelve un valor lógico que se puede usar al programar. library() genera un error cuando el paquete no puede ser cargado.}
<<>>=
library(mosaic)           
# Una alternativa de cargarlo
library(mosaicData)       
# Carga los conjuntos de datos
@
or 
<<>>=
require(mosaic)            
# Otra alternativa para cargarlo
require(mosaicData)        
# Carga los conjuntos de datos
@

\Pointer{Aunque el comando se llama \function{library()}(librería), lo que se carga es un paquete no una librería.}


\Caution{Recuerde que en los archivos Rnw y RMarkdown, cualquier paquete que use tiene que ser cargado \emph{dentro del archivo}.}
\noindent
La viñeta de paquetes en \RStudio\ vuelve instalar y cargar paquetes particularmente fácil y evita la necesidad de usar \function{install.packages()} para paquetes en CRAN, además hace cargar paquetes en la consola tan fácil como seleccionar de un menú. Las funciones \function{require()} y \function{library()} son necesarias incluso en \pkg{RMarkdown}, \pkg{knitr}/\LaTeX y archivos de script.

Si está corriendo en una máquina en la cual no tiene los privilegios para escribir la dirección predeterminada de librería, puede instalar una copia personal del paquete. Si la dirección de su librería personal está primero en \code{R_Libs}, esto probablemente pase automáticamente. De lo contrario, puede especificar la dirección manualmente:

<<eval=FALSE>>=
install.packages("mosaic", lib="~/R/library")
@
%On a networked machine, be sure to use a different local directory for 
%each platform since packages must match the platform.

%Binary packages have been precompiled for a 
%particular platform and are generally faster and easier to set up, if they 
%are available.  Source packages need to be compiled and built on your local
%machine.  Usually this happens automatically -- provided you have all the 
%necessary tools installed on your machine -- so the only disadvantage is the
%extra time it takes to do the compiling and building.

%\subsection{Installing other packages}

\myindex{Bioconductor}
\myindex{github}
CRAN no es el único repositorio de paquetes de \R. Bioconductor es otro gran y popular repositorio, especialmente para aplicaciones biológicas y ha incrementado la cantidad de autores que hacen los paquetes disponibles via github. Por ejemplo, puede también instalar el paquete mosaic usando
\Rindex{install_github()}
\Rindex{devtools}
<<eval=FALSE>>=
# Si no ha instalado devtools
install.packages("devtools")     
require(devtools)
install_github("ProjectMOSAIC/mosaic")
@

Ocasionalmente se puede encontrar un paquete de interés que no está disponible en algún repositorio, puede encontrar instrucciones de cómo instalarlo. Si no, puede usualmente instalarlo directamente de un archivo zip.

<<eval=FALSE,echo=TRUE>>=
# repos = NULL indica que utilice el archivo, no el repositorio
install.packages('some-package.tar.gz', repos=NULL)           
@

%\authNote{Should this box be placed in an earlier chapter?}
\begin{boxedText}
	De aquí en adelante vamos a asumir que el paquete \pkg{mosaic}
	ha sido instalado y cargado
\end{boxedText}


\section{Consiguiendo ayuda}

Si algo no sale bien, o si no puede recordar algo, es bueno saber a dónde buscar por ayuda. Además de preguntar a sus amigos y vecinos, puede usar el sistema de ayuda de \R.
\Rindex{?}

\subsection{?}

Para conseguir ayuda de una función específica o de un conjunto de datos, simplemente escriba \code{?} antes de su nombre:

%\authNote{This isn't working properly}
<<rs-help1,eval=FALSE,tidy=FALSE>>=
?log      # Ayuda para la función log
@
<<rs-help2,eval=FALSE,tidy=FALSE>>=
?HELPrct  # Ayuda para un conjunto de datos en el paquete mosaic.
@
Esto le va mostrar la documentación del objeto en el cual está interesado.

\subsection{\texttt{apropos()}}
\Rindex{apropos()}
Si no sabe exactamente el nombre de una función, puede dar parte del nombre y \R\ va encontrar funciones que calcen. Las comillas son necesarias para esto.
\Pointer{Note que \code{tally} aparece dos veces. Esto es porque hay 2 funciones \code{tally()}, una en el paquete \pkg{mosaic} y otra en el paquete \pkg{dplyr}. La función \code{find()} puede ser utilizada para determinar a qué paquetes pertenece una función. En ese caso, el paquete mosaic se encarga de navegar entre las dos versiones de \code{tally()}. En otros casos, tal vez necesite especificar la función del paquete que quiere.}

<<rs-apropos>>=
apropos('tally')   
# Debe incluir comillas solas o dobles
@

\subsection{\texttt{??} y \texttt{help.search()}}
\Rindex{??}
\Rindex{help.search()}
Si lo anterior falla, puede darle un uso más amplio a \code{??} o \function{help.search()}, que va encontrar parejas no solo entre los nombres de funciones y conjuntos de datos, sino también en la documentación para estos. Las comillas son opcionales aquí.


\subsection{Ejemplos y demos}

Muchas funciones y conjuntos de datos incluyen código de ejemplos demostrando su uso típico. Por ejemplo,
\marginnote{No todos los autores de paquetes son igual de habilidosos 
creando ejemplos. Algunos ejemplos no son existentes o inútiles, otros son excelentes}%
\Rindex{example()}
<<rs-example-histogram,eval=FALSE,results='hide'>>=
example(histogram)
@
va generar unos cuantos gráficos de ejemplos (y proporcionar los comandos utilizados para crearlos). Ejemplos como este tienen la intención de ayudar qué tan específico funcionan las funciones de R. Estos ejemplos también aparecen al final de la documentación para funciones o conjuntos de datos.

El paquete \pkg{mosaic} (y otros paquetes también) también incluye demos. Los demos son pedazos de código de \R\ que puede ser ejecutado usando el comando \function{demo()} con el nombre del demo. Para ver cómo funcionan los demos, intente esto:
\Rindex{demo()}
<<rs-demo,eval=FALSE,results='hide'>>=
demo(lattice)
@
Los demos tienen la inteción de ilustrar un concepto o un método y son independientes de cualquier función particular o conjunto de datos.

Puede también conseguir una lista de demos disponibles usando
<<rs-demo-list,eval=FALSE,results='hide'>>=
demo()                     # todos los demos
demo(package='mosaic')     
# solo los demos del paquete mosaic
@


\section{Data}
\label{sec:studentdata}%
%To be able to undertake analyses, you will need to
%load data sets into \R\ and \RStudio\ for analysis.

\subsection{Data Frames}

\myindex{data frame}
\myindex{variable}
\myindex{observational unit}
Los conjuntos de datos usualmente están almacenados en una estructura llamada \term{data frame}.

\TeachingTip{Los estudiantes que recolectan sus propios datos, especialmente si los almacenan en Excel, es poco probable que pongan los datos en un formato correcto a menos que se les enseñe explícitamente a hacerlo.}

\begin{boxedText}
Los data frames son estructuras de bi-dimensionales.  
\medskip
\begin{itemize}
\item 
Filas, que corresponden a 
\term{unidades de observación} (personas, animales, plantas u otros objetos de los cuales estamos recolectando datos).
\item
Columnas que corresponden a \term{variables} (medidas recolectadas en cada unidad de observación).
\end{itemize}
\end{boxedText}
\TeachingTip[-1cm]{Para ayudar a los estudiantes a mantener las variables y los data frames data frames claros, adoptamos una convención de que los data frames en el paquete \pkg{mosaicData} están en mayúscula y las variables (usualmente) no lo están. Esta convención ha funcionado bien, y quizás lo quiera adoptar en sus conjuntos de datos también.}

El data frame de \dataframe{Births78} contiene cuatro variables medidas para cada día en 1978. Hay varias formas en las que podemos ver cómo es el data frame de Births78.

\newpage

\Rindex{head()}
\Rindex{sample()}
\Rindex{summary()}
<<rs-Births78-head>>=
head(Births78)            #Muestra las primeras filas
@

\Rindex{sample()}
<<rs-Births78-sample>>=
sample(Births78, 4)       #Muestra 4 filas seleccionadas aleatoriamente
@


\Rindex{summary()}
<<rs-Births78-summary>>=
summary(Births78)         
#Proporciona resumenes de información sobre cada variable
@

\enlargethispage{1in}

<<echo=FALSE>>=
oldwidth <- options("width")
options(width=90)
@

\Rindex{inspect()}
<<rs-Births78-inspect>>=
inspect(Births78)     #Brinda un resumen de la información de cada variable
@

<<echo=FALSE>>=
options(oldwidth)
@

\Rindex{str}
\begin{widestuff}
<<rs-Births78-str>>=
str(Births78)             #Muestra la estructura de cualquier objeto R
@
\end{widestuff}

\noindent
\myindex{evironments!R}
La salida de \function{str} está también disponible en la viñeta del entorno.

De forma interactiva, también puede intentar
<<rs-view2,eval=FALSE,tidy=FALSE>>=
?Births78
@
para acceder la documentación del conjunto de datos. Esto también está disponible en la viñeta de \tab{Help}. Finalmente la viñeta de \tab{Environment} proporciona una lista de datos en el entorno global. Presionar un conjunto de datos saca un visor como
\Rindex{View()}
<<rs-view1,eval=FALSE,tidy=FALSE>>=
View(Births78)
@

%\authNote{add pointer to fetchData()?}

%\subsection{Getting at the Variables}
Podemos ganar acceso a una única variable en el conjunto de datos usando el operador \code{\$}, o alternativamente, usando \function{with()}

\Rindex{\$}
\Rindex{with()}
<<rs-dollar-sign,eval=FALSE>>=
dataframe$variable
with(dataframe, variable)
@
Por ejemplo,
<<rs-Births78-births,eval=FALSE>>=
Births78$births
with(Births78, births)
@
va mostrar contenidos de la variable \variable{births} en el conjunto de datos \dataframe{Births78}.

\marginnote{Como vamos a ver, hay relativamente pocas instancias 
en las cuales se necesita el operador \texttt{\$}.}
Listar todo el conjunto de valores para una variable 
particular no tiene mucho uso en conjuntos de datos grandes. Preferimos calcular resúmenes gráficos o numéricos. Pronto lo haremos.

\subsection{Los peligros de \code{attach()}.}
\myindex{attach@\texttt{attach()}!avoid}
\Caution{Evite el uso de \function{attach}.}
La función \function{attach()} en \R\ puede ser usada para hacer que objetos en data frames sean accesibles en \R\ sin tanta escritura, pero nosotros desaprobamos su uso, usualmente guía a conflictos de nombres y otras complicaciones.  
\myindex{Google}
A Google R Style Guide\footnote{
\url{http://google-styleguide.googlecode.com/svn/trunk/google-r-style.html}}
lo afirma  

\begin{quotation}
\emph{Las posibilidades de crear errores al 
usar \function{attach()} son numerosas. Evítelas.} 
\end{quotation}
%It is far better to directly access
%variables using the \code{\$} syntax or to use functions that allow you to 
%avoid the \code{\$} operator.


\subsection{Los datos en los paquetes}
Los conjuntos de datos en los paquetes de \R\ son los más sencillos de trabajar.%
\TeachingTip[-1cm]{Empiece usando datos en paquetes y después enseñándole 
a los estudiantes como importar sus propios datos una vez que hayan 
entendido como trabajar con datos.}%
Los conjuntos de datos en los paquetes de \R\ son los más 
sencillos de trabajar. En la sección 6.5.4, vamos a describir 
como cargar sus propios datos en \R\ y \RStudio\, pero le 
recomendamos empezar con datos de los paquetes, y eso es 
lo que vamos a hacer aquí, también. %{Once students know 
%how to work with data and what data in \R\ are supposed to look
%like, they will be better prepared to import their own data sets.

Muchos paquetes contienen conjuntos de datos. 
Usted puede ver una lista de todos los conjuntos de datos 
en los paquetes cargados usando

\Rindex{data()}
<<rs-data-list,eval=FALSE,results='hide'>>=
data()
@
Puede opcionalmente elegir restringir a la lista de un sólo paquete:
<<rs-data-package-list,eval=FALSE,results='hide'>>=
data(package="mosaic")
@

Típicamente%
\Pointer{Esto depende del paquete. La mayoría de autores ajustan sus 
paquetes con un "lazy loading" de datos. Si no, entonces tiene que 
usar \function{data()} explícitamente.}%
se pueden usar conjuntos de datos simplemente escribiendo sus nombres. Pero si ya ha usado ese nombre para algo o necesita refrescar los datos después de algunos cambios que ya no necesita, puede explícitamente cargarlos usando la función \function{data()}, con el nombre del conjunto de datos que quiere utilizar.

\Rindex{Births78}
<<rs-data-load>>=
data(Births78)
@
%
\Caution{Si dos paquetes incluyen conjuntos de datos con el mismo nombre, 
hay que especificar cual paquete es del que quiere los datos 
\code{data(Births78, package=mosaicData)}.
}%
No hay efecto visible de este comando, pero \dataframe{Births78} ahora acaba de ser re-cargado del paquete \pkg{mosaicData} y está listo para utilizarse. Cualquier cosa que haya hecho anteriormente en algo con un nombre del conjunto de datos es reemplazada por la versión del paquete \pkg{mosaicData}.


\subsection{Usando sus propios datos}
\label{sec:usingdata}
\TeachingTip{Empiece usando datos de paquetes y enfóquese en lo que \R\ puede hacer con los datos. Después, una vez que los estudiantes estén familiarizados con \R\ y entiendan el formato requerido de los datos, enséñeles a importar sus propios datos.}
Eventualmente los estudiantes van a querer dejar de usar datos de ejemplos en paquetes de \R\ y usar datos que han encontrado y recolectado ellos. Cuando esto pase, depende del tipo de estudiantes que tenga y el tipo de curso que esté enseñando.

\Rindex{read.csv()}
\Rindex{read.file()}
\Rindex{read.table()}
\Rindex{load()}
\R\ proporciona las funciones \function{read.csv()} (Para archivos separados por coma), read.table() (para archivos delimitados por un espacio en blanco) y load() (para cargar datos en el formato de R). El paquete mosaic incluye una función llamada read.file() que usa unos ajustes predeterminados un poco distintos e infiere si se debe usar read.csv(), read.table() o load() basado en el nombre del archivo. 

\myindex{Excel}
Puesto que la mayoría de softwares pueden exportar de formato csv, esto se ha vuelto una \emph{lingua franca} para moverse en diferentes softwares. Los datos en excel, por ejemplo, pueden ser exportados como archivos csv y subsecuentemente ser leídos en \R.%
\Rindex{resample()}
\Rindex{readxl}
\Rindex{read_excel}
\Rindex{haven}
%\Caution{There is a conflict between the \function{resample()} functions in
%\pkg{gdata} and \pkg{mosaic}.  If you want to use \pkg{mosaic}'s \function{resample()},
%be sure to load \pkg{mosaic} \emph{after} you load \pkg{gdata}.}
%If you have python installed on your system, you can also use
%\function{read.xls()} from the \pkg{gdata} package to read read directly from
%Excel files without this extra step.
Hay un peligro en hacer esto, sin embargo, algunos tipos de datos no se exportan de Excel cómo se espera. Una forma más segura de leer archivos excel es usar \code{read_excel()} una función del paquete \pkg{readxl}. El paquete \pkg{haven} incluye funciones y utilidades para leer datos en otros tipos de formato que son exportados de paquetes estadísticos como SAS o Stata.

Algunas de estas funciones que ingieren datos aceptan una URL como nombre de archivo, lo cual brinda una forma fácil de distribuir datos via Internet:
%\authNote{Should we change URLs to something at mosaic-web.org?}
\Rindex{read.table()}
\Rindex{head()}

\medskip

\begin{widestuff}
<<tidy=FALSE>>=
births <- 
  read.table('http://www.calvin.edu/~rpruim/data/births.txt', header=TRUE)
head(births) #Nacidos vivos en el año 78 en USA.
@
\end{widestuff}

Podemos omitir el \option{header=TRUE} si usamos \code{read.file()}.
\Rindex{read.file()}

\begin{widestuff}
<<tidy=FALSE>>=
births <- 
  read.file('http://www.calvin.edu/~rpruim/data/births.txt')
@
\end{widestuff}

%\Rstudio\ will help you import your own data.  To do so use the ``Import Dataset" 
%button in the \tab{Environment} tab.  You can load data from text files, from the web, or from
%google spreadsheets.   

\subsection{Importando datos de \RStudio}
\myindex{data!importing into RStudio}
\TeachingTip{Recuérdele a los estudiantes que el proceso de 2 pasos (subir e importar) funciona como las imágenes en Facebook. Primero la sube a Facebook, y después están ahí y se pueden incluir en publicaciones, etc.}%
La interface de \RStudio\ proporciona algunas herramientas GUI para cargar datos. Si está usando el servidor de \RStudio\, primero necesita cargar los datos al servidor (en la viñeta de \tab{Files}), y después importar los datos en la sesión de \R\ (en la viñeta de \tab{Environment})%

Si está utilizando la versión de escritorio, subir el archivo no es necesario.

\subsection{Trabajando con datos pretabulados}
\InstructorNote[-1cm]{Incluso si usa la GUI DE \RStudio\ para el trabajo interactivo, va necesitar saber cómo usar funciones como \function{read.csv} para trabajar en archivos de tipo RMarkdown, o \pkg{knitr}/\LaTeX.}
\myindex{data!pretabulated}

Puesto que los datos categóricos son tan sencillos de resumir en tablas, usualmente las tablas de frecuencia y contingencia se nos dan en lugar de todos los datos. Se pueden ingresar estas tablas manualmente usando una combinación de \function{c()}, \function{rbind()} y \function{cbind()}.
\Rindex{c()}
\Rindex{cbind()}
\Rindex{rbind()}
\TeachingTip[2cm]{Esto es una técnica importante si usa un libro de texto que presenta datos categóricos pre-tabulados}

<<rs-make-table>>=
myrace <- c( NW=67, W=467 )  
#c es de combinar o concatenar
myrace
@

\label{R:make-xtabs}%
<<rs-make-xtabs, tidy=FALSE>>=
mycrosstable <- rbind(               
  NW = c(clerical=15, const=3, manag=6,  manuf=11, 
		 other=5,  prof=7, sales=3, service=17),
  W  = c(82,17,49,57,63,98,35,66)    
			  )
mycrosstable
@
\noindent
Reemplazar \function{rbind()} con \function{cbind()} le va permitir dar los datos en forma de columna
\TeachingTip[-3cm]{Si graficar datos categóricos pre-tabulados es importante, probablemente sólo quiera entregarles a los estudiantes una función que cubra y simplifique todo esto. Generalmente evitamos esta situación, entregando los datos en crudo o presentando un análisis de datos en tabla usando resúmenes gráficos.}

Este arreglo de datos es suficiente para aplicar prueba de ji-cuadrado, pero no lo es para aplicar un formato de gráfico \pkg{lattice}. Nuestra tabla cruzada aún le falta información- los nombres de las variables que están siendo guardadas. Podemos agregar esta información si la convertimos en una tabla.

<<>>=
class(mycrosstable)
mycrosstable <- as.table(mycrosstable)
@

\begin{widestuff}
<<>>=
#mycrosstable ahora tiene dimnames, pero no tienen nombre
dimnames(mycrosstable)
@
<<>>=
# Agreguemos dimnames con sentido
names(dimnames(mycrosstable)) <- c('race', 'sector')
mycrosstable
@
\end{widestuff}

\Rindex{barchart()}
\Rindex{bargraph()}
Podemos usar \function{barchart()} en lugar de \function{bargraph()} para graficar datos ya tabulados, pero primer necesitamos una transformación más.

\enlargethispage{1in}
\Rindex{head()}
\Rindex{as.data.frame()}
<<>>=
head(as.data.frame(mycrosstable))
@

\begin{problem}
La tabla presentada a continuación es de un estudio de la luz nocturna durante la infancia y la visión (más tarde en su vida). 
% latex table generated in R 2.12.1 by xtable 1.5-6 package
% Fri Feb  4 15:46:48 2011
\begin{center}
\begin{tabular}{rrrr}
  \hline
 & sin miopía & miopía & miopía alta \\ 
  \hline
oscuridad & 155 & 15 & 2 \\ 
  luz nocturna & 153 & 72 & 7 \\ 
  luz total & 34 & 36 & 3 \\ 
   \hline
\end{tabular}
\end{center}

\begin{enumerate}
%\item
%Do you think this was an experiment or an observational study?  Why?
\item
Recree la tabla en \R. %Copy and paste the results into your Word document.
\item
¿Qué porcentaje de los sujetos durmieron con luz de noche en su infancia?

Hay varias formas de hacer esto. Puede usar \R\ como una calculadora y hacerlo aritméticamente. Puede evitar esto usando la función \function{tally()}. Vea \code{?tally} para documentación
%If you just want row and column totals added to the table, see \verb!mar_table()!
%in the \verb!vcd! package.
\item Haga una representación gráfica de estos datos. ¿Qué revela?
\end{enumerate}
\end{problem}

\newpage

<<tidy=FALSE,out.width=".8\\textwidth", fig=TRUE>>=
barchart( Freq ~ sector | race,
          data=as.data.frame(mycrosstable),
          auto.key=list(space='right'),
          scales=list(x=list(rot=45))
		  )
@
<<tidy=FALSE,out.width=".8\\textwidth", fig=TRUE>>=
barchart( Freq ~ sector, groups=race, 
          data=as.data.frame(mycrosstable),
          auto.key=list(space='right'),
          scales=list(x=list(rot=45))
		  )
@

\newpage

\subsection{Desarrollando buenos habitos con los datos} 
Aunque usted enseñe a los estudiantes como recolectar e 
importar sus datos, los estudiantes tienen que estar 
entrenados para seguir buenas prácticas de organización 
de datos:
\begin{enumerate}[noitemsep]
\item 
  Elegir buenos nombres para las variables
\item 
  Poner los nombres de las variables en la primera fila
\item 
  Usar una fila subsecuente para cada unidad observacional.
\item 
  Dar al conjunto de datos resultante un buen nombre
\end{enumerate}
Algunos científicos pueden sentirse decepcionados de que los 
conjuntos de datos \R\ no mantienen rastros de 
información adicional, como las unidades en las que 
las observaciones fueron guardadas. Este tipo de información 
debería ser guardada, junto con la descripción de los 
protocolos usados para recolectar estos datos, las 
observaciones hechas durante el proceso de guardado, etc. 
Esta información debe ser mantenida en un libro de 
códigos o una libreta de laboratorio.

%\authNote{NH wants a pointer to wisdom of good data habits.}%

\begin{problem}
Ingrese un pequeño conjunto de datos de una hoja de cálculo de Excel o Google e impórtelo a \RStudio.

\begin{center}
\includegraphics[width=.75\textwidth]{images/GoogleSpreadsheet}
\end{center}
\end{problem}

%\subsection{Putting Data Into a Package}
%
%It is not that difficult to take a collection of csv files (a format available for many books)
%and put them all into a package.
%The \verb!abd! package contains data sets from \textit{The Analysis of Biological Data}, for example.  
%Kevin Middleton and Randall Pruim contacted the authors and obtained permission to 
%build and disseminate this package.
%
%The \verb!abdData()! function in \verb!abd! makes it easy to map examples and exercises in that book to 
%data frame names in the \verb!abd! package.
%
<<rs-findData-human,eval=FALSE,echo=FALSE>>=
abdData('human')         # all data sets with 'human' in the name
@
%
<<rs-findData-2,eval=FALSE,echo=FALSE>>=
abdData(2)               # all data sets in chapter 2
@
%
%For information on how to create such packages, consult the \textit{Writing R Extensions} manual
%on CRAN.

\enlargethispage{1.5in}

\section{Repaso de comandos de R}

\begin{widestuff}
Aquí hay un pequeño repaso de los comandos introducidos en este capítulo
\Rindex{require()}
\Rindex{log()}
\Rindex{log10()}
\Rindex{sqrt()}
\Rindex{c()}
\Rindex{data()}
\Rindex{names()}
\Rindex{head()}
\Rindex{str()}
\Rindex{summary()}
\Rindex{sample()}
\Rindex{read.table()}
\Rindex{read.csv()}
\Rindex{read.file()}
\Rindex{inspect()}

<<tidy=FALSE,results='hide',fig.keep="none", message = FALSE>>=
require(mosaic)                   # Carga el paquete mosaic
require(mosaicData)               
# carga los conjuntos de datos de mosaic
answer <- 42                      
# Guarda el número 42 en el objeto answer
log(123); log10(123); sqrt(123)   
# Algunas funciones numéricas estándar
x <- c(1,2,3)                     
# Generar un vector que contiene 1, 2 y 3

data(iris)                        
# carga de nuevo el conjunto de datos iris
names(iris)                       
# ver los nombres de iris
head(iris)                        
# las primeras filas del conjunto iris
sample(iris, 3)                   
# 3 filas aleatorias de iris
inspect(iris)                     
# resume cada variable del conjunto de datos iris
summary(iris)                     
# resume cada variable del conjunto de datos
str(iris)                         
# Muestra la estructura del conjunto de datos

mydata <- read.table("file.txt")  
# Lee los datos de un archivo de texto
mydata <- read.csv("file.csv")    
# lee los datos de un csv
mydata <- read.file("file.txt")   
# lee los datos de un csv o un archivo de texto
require(readxl)
mydata <- read_excel("file.xlsx") 
# lee los datos de un archvivo excel
@

\end{widestuff}
\newpage
\section{Ejercicios}

\shipoutProblems

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(fig.path="figures/RForInstructors-", tidy=FALSE)
opts_chunk$set()
set.seed(123)
require(fastR)
@

\chapter{Lo que los instructores necesitan saber de R}
\label{chap:RForInstructors}
\label{chap:containers}



\marginnote{Es posible que piense que algunas de estas cosas son útiles para que las conozcan sus estudiantes. Eso va depender de las metas de su curso y las habilidades de los estudiantes. En los cursos de mayor nivel, mucho del material en este capítulo es apropiado para estudiantes..}
Recomendamos mantener la cantidad de \R\ que los estudiantes deben saber al mínimo, y elegir funciones que utilicen y apoyen la notación de fórmula cuando sea posible, para mantener las funciones con sintaxis similares. Sin embargo, hay algunas cosas adicionales que los instructores (y tal vez algunos estudiantes) deben saber de \R. Resaltamos algunas en este capítulo.

\section{Algunas recomendaciones del ciclo de trabajo}
\label{sec:scripts}

Nuestro consejo de flujo de trabajo puede ser resumido en una pequeña oración: 

\begin{center}
\emph{Piense como un programador.}  
\end{center}

\BlankNote{No pensamos que nuestra clase use R para programación puesto que usamos R mayormente de forma declarativa, no algorítmica}%

No requiere habilidades de programación muy sofisticadas para ser bueno usando \R. De hecho, la mayoría de los usos de \R\ para enseñar estadística pueden hacerse un paso a la vez, donde cada línea de código hace una útil tarea completa. Después de inspeccionar la salida (y guardarlo para posibles cálculos o computaciones después), uno puede proceder a la próxima operación

Sin embargo, podemos pedir prestado del conocimiento colectivo de la comunidad programadora y adoptar algunas prácticas que van a hacer nuestra experiencia más placentera, más eficiente y con menor probabilidad de errores.

\begin{itemize}
  \item Guarde su código en un documento.   %# rather than entering it at the prompt.

  Puede ser tentador hacer todo en la consola. Pero esta es efímera. Es mejor tener el  
  hábito de guardar archivos con el código. Haga el hábito (y haga que sus estudiantes
  tengan   ese hábito) de trabajar con scripts de R y especialmente archivos de RMarkdown..  

\Pointer[0cm]{\R\ puede ser utilizado para crear scripts ejecutables. Opciones para análisis y manejo es apoyado en el paquete \pkg{optparse}.}

Puede correr todo el código de R usando
\Rindex{source()}
<<mr-source,eval=FALSE>>=
source("file.R") 
@
\noindent
\RStudio\ tiene opciones adicionales para ejecutar todas las líneas en un documento. Vea los botones en la viñeta para cualquier archivo \R\ script, RMarkdown o Rnw. (Puede crear un archivo en el menú principal del menú \tab{File})

Si usted trabaja en la entrada de la consola interactiva y ha estado poniendo comandos en un archivo, puede guardarlos con:

\Rindex{savehistory()}
<<eval=FALSE,echo=TRUE>>=
savehistory("someRCommandsIalmostLost.R")
@
\RStudio\ Puede selectivamente copiar porciones de su historia en un archivo de script (o la consola) usando la viñeta de \tab{History}.

  \item Use nombres con significado.

	  Raramente los objetos deberían ser llamados con una sola letra.  
	  
  Adopte una convención personal respecto a esto en caso de letras.
  Esto significa que tiene una cosa menos que recordar cuando 
  intente llamar un objeto. Por ejemplo, en el paquete \pkg{mosaicData}, todos 
  los conjuntos de datos empiezan con mayúscula. La mayoría de las variables 
  empiezan con una no mayúscula (hay algunas excepciones para variables con 
  nombres que se sabe por qué están en mayúscula).

  \item
	  Adopte modismos reutilizables

\enlargethispage{1in}

	  Los programadores se refieren a pequeños patrones que recurren alrededor de su código como modismos. Por ejemplo, aquí está el "compute, guarde, despliegue"
	  idiom.
<<idiom, tidy=FALSE>>=
# compute, guarde y despliegue
footModel <- lm(length ~ width, data=KidsFeet); footModel
@

<<idiom2, tidy=FALSE>>=
# Alternativa que refleja el orden de las operaciones
lm(length ~ width, data=KidsFeet) -> footModel; footModel
@

	  Usualmente hay múltiples maneras de hacer lo mismo en \R,
	  pero si adopta buenos modismos de programación, 
	  va ser más claro para usted y sus estdiantes qué 
	  estaba haciendo

  \item Use funciones reutilizables

  Aprender a escribir sus propias funciones (ver sección 7.7) va incrementar su eficiencia y también lo va a ayudar a entender mejor como \R\ funciona. Esto, de regreso, le va a ayudar a solucionar los mensajes de error de su estudiantes.(Más mensajes de error en 7.10). También hace posible simplificar tareas que quiere que los estudiantes hagan en \R. Así es como el paquete mosaic es originado -- como una colección de herramientas que hemos ensamblados durante el tiempo para hacer la enseñanza y el aprendizaje más sencillo.

  \item Comente su código.

\Rindex{\#}%
\myindex{comment character in R@comment character in {\sf R} (\texttt{\#})}%
Es increíble lo que uno puede olvidar. El signo de comentario en \R\ es \texttt{\#}. Si está trabajando en RMarkdown o Rnw, puede incluir texto en un buen formato para describir lo qué está haciendo y por qué.
\end{itemize}

\section{Estructuras de datos de \R\ primarias}
\label{sec:datastruct}

Todo en \R\ es un objeto de una clase particular y entendiendo los tipos de objetos que \R\ usa le quita el misterio a bastantes mensajes que \R\ produce, además de comportamientos inesperados de comandos que no funcionan de la manera que se esperaba. No vamos a intentar darle una descripción exhaustiva de la taxonomía de objetos de \R, pero en su lugar, nos vamos a enfocar en unas cuantas características importantes y ejemplos.


\subsection{Objetos y clases} % Modes and other attributes} %factors, numeric, character, etc.}
\myindex{object}
\myindex{class}
En \R, los datos son guardados en \rterm{objetos}. Cada objeto tiene un \emph{nombre, contenido y una clase}. La clase de un objeto nos dice qué tipo de cosa es. La clase de un objeto puede ser pedida usando \function{class()}
\Pointer[-2cm]{Muchos objetos también tienen \emph{atributos} que contienen información adicional del objeto, pero a menos que esté programando con estos objetos, no se tiene que preocupar mucho por estos.}%
%
\Rindex{class()}%
\Rindex{[ ]}%
\Rindex{[[ ]]}%

<<class>>=
class(KidsFeet)
class(KidsFeet$birthmonth)
class(KidsFeet$length)
class(KidsFeet$sex)
str(KidsFeet)                  
#Muestra la clase para cada variable
@
\Rindex{KidsFeet}

\Pointer{Una diferencia entre un factor y una variable de texto es que el factor sabe los posibles valores, incluso si algunos de ellos no ocurren. A veces esto es una ventaja (para tabular celdas vacías en una tabla) y a veces una desventaja (cuando los factores son utilizados como identificadores únicos)} De aquí, vemos que KidsFeet es un conjunto de datos con variables de diferentes tipos (enteros, numéricas y factores). Estos tipos de variables es posible que las encuentre, aunque puede ver variables lógicas(TRUE o FALSE) o de tipo character(texto) también.

Los factores son la forma más común de datos categóricos que se puede almacenar en \R, pero a veces la clase de texto (character) puede ser mejor. La clase de un objeto determina qué cosas pueden hacerse y cómo aparece cuando es impreso, graficado o desplegado en la consola..


\subsection{Containers}

La situación es actualmente un poco más complicada. La variable \variable{birthmonth} en \dataframe{KidsFeet} no es un único entero, es una colección de enteros
\Pointer{Incluso cuando tenemos solamente un entero, R lo va tratar como un contenedor de enteros con sólo un entero en él.} %
Hay más de un tipo de contenedor en \R. Los contenedores usados para variables en el conjunto de datos se llaman \term{vectores}.
\myindex{vector}%
Estas cosas dentro de un vector están ordenadas (empezando con 1) y deben ser del mismo tipo.  

Los vectores pueden ser creados usando la función \function{c()}:
\Rindex{c()}

<<>>=
c(2, 3, 5, 7)
c("Abe", "Betty", "Chan")
c(1.2, 3.2, 4.5)
@
Si usted intenta poner diferentes tipos de objetos en un mismo vector, \R\ va intentar convertirlos todos en el mismo tipo de objeto. 
\Caution[-1.5in]{Cuando se lee los datos creados en otros software (como Excel) o guardados en un archivo CSV, es importante saber cómo los datos faltantes fueron indicados, de otra forma, el código para los datos faltantes puede ser interpretado como un character, causando todos los otros artículos o cosas en esa columna sean convertidos en valores character también, perdiendo una parte importante de la información.}%
%
Si no lo logra, va generar un error.
<<tidy=FALSE>>=
x <- c(1, 1.1, 1.2); x    
#Convierte el entero en numérico
class(x)
y <- c(TRUE, FALSE, 0, 1, 2); y     
#Convierte los lógicos a numéricos
class(y)
z <- c(1, TRUE, 1.2, "vector"); z   
#Todos convertidos a character(texto)
class(z)
@

\DiggingDeeper{Un factor puede ser ordenado o no ordenado (que puede afectar como los estadísticos de prueba se desempeñan, de otra forma no importa mucho). El predeterminado para los factores son no ordenados. Si los factores son ordenados o desordenados, los niveles van a aparecer en un orden fijado -- alfabético. La distinción entre los factores ordenados y desordenados está relacionado con si el orden es importante o es arbitrario}%
%
Los factores pueden ser creados envolviendo un vector con \function{factor()}:
\Rindex{factor()}
<<tidy=FALSE>>=
w <- factor(x); w
class(w)
@
Note como los factores despliegan sus \term{niveles} (posibles valores) como también los valores por sí mismos. Cuando los datos categóricos son codificados como enteros, es importante recordar convertirlos a factores para ciertos procedimientos estadísticos y gráficos.

Enteros con patrones o vectores numéricos pueden ser creados usando el operador \code{:} o la función \function{seq()}.
\Rindex{seq()}

\begin{widestuff}
<<>>=
1:10
seq(1, 10, by=0.5)
@
\end{widestuff}

\Rindex{[ ]}%
Los artículos individuales en un vector pueden ser accedidos o asignados usando el operador de paréntesis cuadrado:
<<>>=
w[1]
x[2]
y[3]
@

Los valores faltantes están codificados como \code{NA} (no disponibles). Preguntar por una entrada fuera de los alcances de un vector devuelve un \code{NA}. Asignar un valor fuera del alcance del vector resulta en un vector que se hace del tamaño de tal forma que el nuevo valor pueda ser guardado en la posición apropiada.
<<>>=
z[5]    #Esto no es un error, pero devuelve un NA
q <- 1:5
q
q[10] <- 10   
#Los elementos de 6 a 9 se rellenan con un NA
q
@

\R\ también proporciona algunas característica más inusuales (pero muy útiles) para acceder a los elementos de un vector.

\Rindex{letters[ ]}%
\Rindex{LETTERS[ ]}%

\begin{widestuff}
<<>>=
letters                       # alfabeto
@
\end{widestuff}

\Pointer{\variable{letters} is a built-in character vector containing the lower case letters.  \variable{LETTERS} contains capitals.}%
<<>>=
x <- letters[1:10]; x         # Primeras 10 letras
x[2:4]                        
# seleccione lo contenido de 2 a 4
x[2:4] <- c("X","Y","Z"); x   
# Cambiar lo contenido de 2 a 4
y <- (1:10)^2; y              
# Primeros 10 cuadrados
y [ y > 20 ]                  
# selecciona aquellos mayores a 20
@
El último elemento merece un poco de comentarios. La expresión adentro de los paréntesis cuadrados evalúa a un vector de valores lógicos.
<<echo=FALSE>>=
oldparams <- options()
options(width = 90)
@
<<>>=
y > 20
@
<<echo=FALSE>>=
options(oldparams)
@
Los valores lógicos después son usados para seleccionar (true) o no seleccionar (false) los elementos en el vector, produciendo un nuevo (y potencialmente más pequeño) vector. Si el número de valores lógicos proporcionados es menor que la cantidad de valores del vector, los valores están siendo \term{reciclados} (repetidos).
<<>>=
y[ c(TRUE,FALSE) ]          # cada uno
y[ c(TRUE,FALSE,FALSE) ]    # Cada tercero
@
%If the recycling doesn't come out even, a warning is displayed.

\myindex{matrix}
\myindex{array}
Una \term{matriz} es una tabla de valores bi-dimensional, o sea de valores que tienen el mismo tipo. Como con los vectores, todo adentro de ellos debe ser del mismo tipo. Pero las matrices son bi-dimensionales -- cada dato dentro de ellas está localizado en una fila y columna. Un \term{array} es una versión multi-dimensional de una matriz. Las matrices y los arrays son contenedores importantes para el trabajo estadístico, pero poco probable que sean utilizados por principiantes.
<<>>=
M <- matrix(1:15, nrow=3); M    # a 3 x 5 matrix
@
Las dimensiones de un array, matriz o data frame pueden ser obtenidas usando \function{dim()}, \function{nrow()} y \function{ncol()}
\Rindex{dim()}%
\Rindex{nrow()}%
\Rindex{ncol()}%
\Rindex{matrix()}%
<<>>=
dim(M)
dim(KidsFeet)
nrow(KidsFeet)
ncol(KidsFeet)
@

\myindex{list}
\Pointer{En el habla oficial de \R, la distinción que hacemos entre vectores y listas es realmente una distinción entre vectores \emph{atómicos} y \emph{listas} (que también se llaman vectores \emph{genéricos}). De hecho, ellos deben ser del mismo tipo \emph{atómico}. Los vectores atómicos son los cimientos para \R. No es posible guardar objetos más complicados (como data frames) en un vector, pero pueden ser guardados en una lista.).}%

Otro contenedor comúnmente utilizado en \R\ es la lista. Ya hemos visto algunos ejemplos de listas, como argumentos de funciones de gráficos de \pkg{lattice}. Las listas son ordenadas, pero los datos en una lista pueden ser objetos de cualquier tipo, no necesitan ser todos del mismo tipo. Sin maquillaje, un data frame es una lista de vectores con la restricción de que cada vector debe tener el mismo tamaño (contener el mismo número de datos).

\Rindex{length()}
Las listas pueden crearse usando la función \function{list()}.
<<>>=
l <- list(1, "two", 3.2, list(1, 2)); l
length(l)       #Note que l tiene 4 elementos, no 5
@
Se puede acceder a los atos en la lista con un doble paréntesis cuadrado \code{([[ ]])}
<<>>=
l[[1]]
@
Usando un único paréntesis cuadrado(\code{[ ]}) en su lugar, devuelve una sublista en lugar de un elemento. Entonces \code{l[[1]]} es un vector, pero \code{l[1]} es una lista que contiene un vector.
\Rindex{[[ ]]}%
<<>>=
l[1]
@

\Rindex{names()}%
Ambos vectores y listas pueden tener nombres. Los nombres pueden ser creados cuando el vector o la lista es creada o pueden ser puestos después. Se puede acceder a los elementos del vector y la lista por nombre o por posición.
\Rindex{list()}
\Rindex{names()}
<<>>=
x <- c(one=1, two=2, three=3); x
y <- list(a=1, b=2, c=3); y
x["one"]
y[["a"]]   # retrieve items from a list with [[ ]]
names(x)
names(x) <- c("A", "B", "C"); x
@


Los operadores de acceso - \code{[ ]} y \code{[[ ]]} para las listas -- son en realidad funciones en \R. Esto tiene consecuencias importantes:
\begin{itemize}
  \item Acceder a elementos en un vector es más lento en lenguajes como C/C++ 
  donde el acceso es hecho por un puntero aritmético.
  \item
  Estas funciones pueden tener argumentos con nombre, entonces puede ver el código así
\end{itemize}

<<"bracket-function">>=
M
M[5]
M[,2]                   #Esto es 1-d (un vector)
M[,2, drop=FALSE]       #Esto es 2-d (todavía una matriz)
@


\Rindex{data.frame()}%
Los data frames pueden ser construidos suministrando \function{data.frame()} a las variables(como vectores):
<<attributes>>=
ddd <- data.frame(number=1:5, letter=letters[1:5])
@



%\section{More About Vectors}
%\label{sec:Rvectors}
%In Section~\ref{sec:generatingData} we learned how to generate some simple
%vectors.  Here we will learn about some of the operations and functions
%that can be applied to vectors.


\subsection{Funciones vectorizadas}

\myindex{vectorized functions}
Los vectores son tan importantes para \R\ que merecen alguna discusión adicional. Muchas funciones de \R\ y operaciones son "vectorizadas" y pueden ser aplicadas no sólo a un valor individual, sino a un vector completo, que en este caso se les aplica a todas las componentes y muestra un vector de valores transformados. Muchas de las funciones más utilizadas de las matemáticas funcionan de esta forma.
\Rindex{mean()}%
\Rindex{sd()}%
\Rindex{var()}%
\Rindex{median()}%
\Rindex{log()}%

<<vectors01,tidy=FALSE>>=
x <- 1:5; y <- seq(10, 60, by=10) 
x
y
y + 1                     #Agrega un 1 a cada elemento
x * 10                    #Multiplica por 10 cada elemento
x < 3                     #Verifica cual es menor a 3
x^2                       #El cuadrado de cada elemento
sqrt(x)                   #Raíz cuadrada de cada elemento
log(x)                    #Log natural
log10(x)                  #Log base 10
@

\enlargethispage{1in}

\noindent
Los vectores puede combinarse en una matriz usando \function{rbind()} o \function{cbind()}. Esto puede facilitar comparaciones poniéndolas una al lado de la otra 
This can facilitate side-by-side comparisons.
\Rindex{rbind()}%
\Rindex{cbind()}%
\Rindex{round()}%
\Rindex{signif()}%

<<vectors01a,tidy=FALSE>>=
#compare round() y signif() juntando por fila en una matriz
z <- rnorm(5); z
rbind(round(z, digits=3), signif(z, digits=3))   
@


\subsection{Funciones que actúan sobre vectores como vectores}

Otras funciones, incluyendo muchas funciones estadísticas, 
son diseñadas para calcular un único número (técnicamente un 
vector de tamaño 1) de todo un vector.

<<vectors02, tidy=FALSE>>=
z <- rnorm(100)
#Funciones estadísticas básicas; note el uso de los nombres
c(mean=mean(z), sd=sd(z), var=var(z), median=median(z))  
range(z)                    
x <- 1:10
c(sum=sum(x), prod=prod(x))   #sumatorias y productos
@

Incluso, otras funciones devuelven vectores que son derivados del 
vector original, pero no como una transformación de los componentes.
\Rindex{sort()}
\Rindex{rank()}
\Rindex{diff()}
\Rindex{ediff()}
\Rindex{cumsum()}
\Rindex{cumprod()}
\Rindex{order()}

\begin{widestuff}
<<vectors02a, tidy=FALSE>>=
z <- rnorm(5); z
@
<<tidy=FALSE>>=
sort(z); rank(z); order(z) 
@
<<vectors02b, tidy=FALSE>>=
x <- 1:10
rev(x)           # reverso x
diff(x)          #diferencias de pares
ediff(x)         #Diferencias sin cambiar el tamaño
cumsum(x)        #Suma acumulativa
cumprod(x)       #Producto acumulado
@
\end{widestuff}

\label{r:sumprod}%

Que una función esté vectorizada o trato el vector como una unidad depende de su implementación.  
Usualmente, las cosas son implementadas de la manera que usted lo espera. 
\Pointer{La función \function{Vectorize()} es una herramienta útil para convertir una función no vectorizada en una función vectorizada.}%
Ocasionalmente puede descubrir que una función que usted quería vectorizada no lo es. Cuando escribe sus propias funciones, piense un poco si debería ser vectorizada, y pruebela con vectores de tamaño mayor a 1 para asegurarse que consiga el comportamiento que quería.
\Rindex{sum()}%
\Rindex{prod()}%
\Rindex{cumsum()}%
\Rindex{cumprod()}%
\Rindex{cummin()}%
\Rindex{cummax()}%
\Rindex{diff()}%
\Rindex{rev()}%
\Rindex{sort()}%
\Rindex{rank()}%
\Rindex{order()}%
\Rindex{which()}%
\Rindex{any()}%
\Rindex{unique()}%
\Rindex{table()}%
\Rindex{paste()}%
\Rindex{na.omit()}%
\Rindex{pmin()}%
\Rindex{pmax()}%

\hfill\newpage

Las operaciones abajo pueden ser de ayuda cuando escribe sus propias funciones.

\label{table:useful-functions}%
\begin{center}
  \begin{longtable}{|p{1.2in}|p{4.0in}|}
  \hline
  \verb!cumsum()!

  \verb!cumprod()!

  \verb!cummin()!

  \verb!cummax()!
  &
  Devuelve un vector de acumulativos de sumatorias, restas, productorias
  máximos y mínimos.
  \\ \hline
  \verb!pmin(x,y,...)!

  \verb!pmax(x,y,...)!
  &
  Devuelve un vector de paralelos de mínimo o máximo donde el elemento $i$ésimo es
  max o min de \verb!x[i]!, \verb!y[i]!, \dots. 
  \\ \hline
  \verb!which(x)! 
  &
 Devuelve un vector de indices de elementos de \verb!x! que son verdaderos
  Uso típico: \verb!which(y > 5)! devuelve indices de donde los elementos
  de \verb&y& son mayores a 5.
  \\ \hline
  \verb!any(x)! 
  &
  Devuelve un \verb!logical! indicando si algún elemento de \verb!x!
  es verdadero
  Uso típico: \verb!if (any(y > 5)) { ...}!.
  \\ \hline
  \verb!na.omit(x)! & Devuelve un vector sin valores perdidos
  \\ \hline
  \verb!unique(x)! & Devuelve un vector sin valores repetidos
  \\ \hline
  \verb!table(x)! & Devuelve una tabla que cuenta el número de 
   ocurrencias de cada valor en \verb!x!. La tabla es similar
  a un vector con nombres indicando los valores, pero no es un vector.
  \\ \hline
  \verb!paste(x,y,...,!
  
  \verb!  sep=" ")! 
  & Copia \verb!x! y \verb!y! juntos
  en un componente (como strings) con \verb!sep! entre los elementos.
  Reciclando aplicaciones
  \\ \hline
  \end{longtable}
\end{center}



%\iffalse
%\subsection{Reciclando}
%\myindex{recycling}%
%When vectors operate on each other, the operation is done componentwise, 
%recycling the shorter vector to match the length of the longer.

%<<vectors03>>=
%x <- 1:5; y <- seq(10, 70, by=10)
%x + y
%@

%\noindent
%In fact, this is exactly how things like \code{x + 1} actually work.
%If \variable{x} is a vector of length $n$, then \verb!1! (a vector of length 1) is 
%first recycled into a vector of length $n$; then the two vectors are
%added componentwise.
%Some vectorized functions that take multiple vectors as arguments
%will first use recycling to make them the same length.

%\subsection{Accessing elements of vectors}
%\R\ allows for some very interesting and useful methods for accessing
%elements of a vector that combine the ideas above.
%First, recall that the \code{[ ]} operator is actually a function.
%Furthermore, it is vectorized.

%<<vectors04a>>=
%x <- seq(2, 20, by=2)
%x[1:5]; x[c(1, 4, 7)]
%@

%\code{[ ]} accepts logical (i.e. boolean) arguments well.
%The boolean values (recycled, if necessary)
%are used to select or deselect elements of the vector.

%<<vectors04b>>=
%x <- seq(2, 20, by=2)
%x[c(TRUE, TRUE, FALSE)]      # skips every third (note recycling)
%x[x > 10]                    # more typical use of boolean in selection
%@

%\noindent
%Negative indices are used to omit elements.

%<<vectors04c>>=
%x[-c(2,4)]                   # all but 2nd and 4th
%@

%\noindent
%Here are some more examples.
%\Rindex{toupper()}%
%\Rindex{tolower()}%

%<<vectors04d>>=
%notes <- toupper(letters[1:7]); a <- 1:5; b <- seq(10, 100, by=10)
%toupper(letters[5:10])                
%paste(letters[1:5], 1:3, sep='-')
%a+b
%(a+b)[ a+b > 50]
%length((a+b)[a+b > 50])
%table(a+b > 50)
%@

%\includepdf[pages=35-39,frame]{Paradis-rdebuts_en.pdf}

%\includepdf[pages=36-37,landscape,rotateoversize,turn=false,nup=1x2,frame]{Paradis-rdebuts_en.pdf}

%\fi

\section{Trabajando con datos}
\label{sec:MoreR-Data}%

En la sección 6.5 discutimos usar datos de paquetes de \R, y en la sección 6.5.4 discutimos traer nuestros propios datos a \R. En ambos escenarios, hemos asumido que los datos fueron introducidos y limpiados en otro software y todo se enfocó primariamente en importar los datos. En esta sección discutimos formas de crear y manipular datos con \R. Pero primero, vamos a disctuir algunos detalles más sobre la importación de datos.


\subsection{Control más fino de la importación de datos}
\myindex{data!importing}

\marginnote[-2cm]{Incluso si usted primariamente usa la interface de \RStudio\ para importar sus datos, es bueno saber sobre los métodos de la línea de comando, puesto que estos son requeridos para importar datos en documentos script, RMarkdown y \pkg{knitr}/\LaTeX.}
Los argumentos \option{na.strings} pueden ser utilizados para especificar códigos de missing values. Ajuste los \code{na.strings} como en la lectura siguiente de los archivos csv que pueden ser producidos por sistemas como SAS.

\Rindex{na.strings}
<<tidy=FALSE>>=
someData <- read.csv('file.csv', 
  na.strings=c('NA','','.','-','na'))
@
SAS usa un punto (\verb!.!) para codificar los datos faltantes y algunos exportadores de csv usan '\texttt{-}'. Si no se hace la definición anterior o alguna parecida de los na.string, \R\ va tratar los marcados de datos faltantes como datos normales, en lugar de \code{NA}. Esto fuerza a toda la variable a ser de tipo character (texto) aunque puede ser puramente numérica.
\Pointer[-2cm]{La función \function{read.file()} en el paquete \pkg{mosaic} usa esto como predeterminado de los \code{na.strings}.}
\Rindex{read.file()}
\Rindex{read.csv()}
\Rindex{read.table()}
\Rindex{stringsAsFactors}
De forma predeterminada, \R\ va recodificar los datos de tipo character (texto) como un factor. Si prefiere dejar esas variables en formato character(texto), puede usar
\Pointer{Esto funciona como \function{read.csv()} y \function{read.table()} también}
<<tidy=FALSE>>=
someData <- read.file('file.csv', 
  stringsAsFactors=FALSE) 
@

Un control incluso más fino puede ser obtenido manualmente ajustando la clase (tipo) usado para cada columna en el documento. Además, esto acelera la lectura del documento. Para un archivo .csv con cuatro columnas, podemos declararlas para ser de clase entera, numérica, character (texto), y factor con el siguiente comando.
<<tidy=FALSE>>=
someData <- read.file('file.csv', 
  na.strings=c('NA','','.','-','na'), 
  colClasses=c('integer','numeric','character','factor')) 
@

\subsection{Ingresando los datos manualmente}

\Rindex{c()}
Ya hemos visto que la función \function{c()} puede ser utilizada para combinar elementos en un sólo vector..
<<label="c-function",tidy=FALSE>>=
x <- c(1, 1, 2, 3, 5, 8, 13); x
@

La función \function{scan()} puede acelerar la entrada de datos en la consola permitiéndole borrar las comas.
\Rindex{scan()}%
Valores individuales son separados por un espacio en blanco o nuevas líneas. Una línea en blanco es usada como señal del fin de los datos. Como predeterminado, \function{scan()} espera datos numéricos, pero es posible decirle a \function{scan()} que espere algo más, como datos en texto. 
\Caution{Cuando use \function{scan()} asegúrese de recordar guardar los datos en algún lado. De otra forma, va tener que escribirlos de nuevo.}
Hay otras opciones para los tipos de datos, pero los numéricos y de texto son los más importantes de manejar. Vea \code{?scan} para más información y ejemplos.

\subsection{Simulando distribuciones muestrales}
\R\ tiene funciones que hacen simple muestrear de un amplio rango de distribuciones. Cada una de estas funciones empieza con la letra 'r' (de 'random') seguido del nombre de la distribución (usualmente abreviada). Los argumentos de la función son para especificar el tamaño de muestra deseada y cualquier valor paramétrico requerido para la distribución. Por ejemplo, para simular elegir una muestra de tamaño 12 de una población normal con media 100 y desviación estándar 10, usamos:
\Rindex{rnorm()}

\begin{widestuff}
<<>>=
rnorm(12, mean=100, sd=10)
@
\end{widestuff}

Las funciones para muestrear de otras distribuciones incluyen: 
\function{rbinom()},
\function{rchisq()},
\function{rt()},
\function{rf()},
\function{rhyper()},
etc.

Es también hacer hacer una muestra (con o sin reemplazo) de datos existentes usando \function{sample()} y \function{resample()}.
<<>>=
x <- 1:10 
#muestra aleatoria de tamaño 5 de x (sin reemplazo)
sample(x, size=5)         
#muestra aleatoria de tamaño 5 de x(con reemplazo)
resample(x, size=5)         
@
\Rindex{resample()}
Usar \function{resample()} hace más fácil simular distribuciones pequeñas discretas. Por ejemplo tirar 20 dados. Podemos usar
<<>>=
resample(1:6, size=20)
@
\Rindex{Cards}
\Rindex{deal()}
Para trabajar con cartas, el paquete \pkg{mosaicData} proporciona un vector llamado \dataframe{Cards} y \function{deal()} como una alternativa de \function{sample()}.
<<>>=
deal(Cards, 5)    #Mano de poker
deal(Cards, 13)   #Un bridge? alguien?
@
Si quiere repartir las manos bien, puede crear un factor de \variable{Cards} primero:
\Rindex{sort()}
\Rindex{factor()}

\begin{widestuff}
<<>>=
hand <- deal(factor(Cards, levels=Cards), 13) 
sort(hand)       # sorted by suit, then by denomination
@
\end{widestuff}

%\iffalse
%\subsection{Creating data frames from vectors}

%\Rindex{data.frame()}%
%The \function{c()} and \function{scan()} functions put data into a 
%\rterm{vector}, not a \rterm{data frame}.  We can
%build a data frame from vectors using \function{data.frame()}.

%<<dataframe>>=
%color <- c("red", "green", "blue")
%number <- c(3, 5, 4)
%myDataFrame <- data.frame(col=color, num=number)
%myDataFrame
%@
%\fi
 

%\iffalse
%\subsection{Generating data}
%\label{sec:generatingData}
%\Rindex{rep()}%
%\Rindex{seq()}%
%\Rindex{c()}%
%\Rindex{rnorm()}%
%\Rindex{sample()}%

%The following code shows a number of ways to generate data systematically.
%This can be useful for designing experiments, for creating illustrations,
%or for performing simulations.

%<<generatingData01,tidy=FALSE>>=
%# all integers in a range
%x <- 5:20; x                 
%# structured sequences
%seq(0, 50, by=5)               
%seq(0, 50, length=7)               
%rep(1:5, each=3)
%rep(1:5, times=3)
%# c() concatenates vectors
%c(1:5, 10, 3:5)              
%@

%\R\ can also sample from several different distributions.

%<<generatingData02>>=
%# random draws from normal distribution
%rnorm(10, mean=10, sd=2)  
%x <- 5:20                 # all integers in a range
%# random sample of size 5 from x (no replacement)
%sample(x, size=5)         
%# a different random sample of size 5 from x (no replacement)
%sample(x, size=5)         
%# random sample of size 5 from x (with replacement)
%resample(x, size=5)         
%@
%\fi

\begin{example}
Para propósitos de enseñanza, en ocasiones es bueno crear un histograma que tiene la forma apróximada de una distribución. Una forma de hacer esto es muestrear aleatoriamente la muestra de una distribución deseada y hacer un histograma del resultado
<<>>=
x1 <- rnorm(500, mean=10, sd=2)
histogram( ~ x1, width=.5)    
@
Esto funciona, pero el gráfico resultante tiene una cantidad alta de ruido.

La función \function{ppoints()} devuelve probabilidades igualmente espaciadas que nos permiten obtener cuantiles teóricos de la distribución normal. El gráfico que resulta de esto, ilustra la muestra ideal de una distribución normal.
<<>>=
x2 <- qnorm(ppoints(500), mean=10, sd=2)
histogram( ~ x2, width=.5)
@
Esto no es como los datos reales se van a ver (incluso si vienen de una población normal), pero puede ser mejor para propósitos ilustrativos remover el ruido.
\end{example}

\medskip

%\subsection{Summarizing and Aggregating with \pkg{plyr}}

\subsection{Guárdando los datos}
\function{write.table()} y \function{write.csv()} pueden ser usados para guardar datos de \R\ en archivos planos.

<<writingData>>=
ddd <- data.frame(number=1:5, letter=letters[1:5])
write.table(ddd, "ddd.txt")
write.csv(ddd, "ddd.csv")
@


Para más de una importación o exportación de datos, especialmente de otros formatos, vea el manual de \emph{R Data Import/Export} (Importanción/Exportación de datos en R) disponible en.
\Pointer[-1cm]{Si quiere salvar un objeto en \R\ pero no su nombre, puede usar la función \function If you want to save an \R\ object but not its name, you can use \function{saveRDS()} and choose its name when you read it with \function{readRDS()}.}
%\begin{itemize}
%  \item 
%  Complete information about the objects is saved, including attributes.
%  \item
%  Data saved this way takes less space and loads much more quickly.
%  \item
%  Multiple objects can be saved to and loaded from a single file.
%\end{itemize}
%The downside is that these files are only readable in \R.

%<<savingData,exec=FALSE,echo=TRUE>>=
%abc <- "abc"
%ddd <- data.frame(number=1:5, letter=letters[1:5])
%# save both objects in a single file
%save(ddd, abc, file="ddd.rda")   
%# load them both
%load("ddd.rda")                  
@


%For more on importing and exporting data, especially from other
%formats, see the 
%\href{http://cran.r-project.org/manuals.html}%
%\textit{R Data Import/Export} manual available on \cran.



\section{Manipulating Data Frames with \texttt{dplyr}}
\label{sec:manipulatingData}%

Hay algunas formas de manipular data frames en \R. El abordaje que ilustramos aquí depende mucho de las funciones en el paquete \pkg{dplyr}. Este paquete es cargado cuando el paquete \pkg{mosaic} es cargado. El paquete \pkg{dplyr} define cinco operaciones primarias en un data frame.

\begin{enumerate}
  \item \function{mutate()} -- agregar o cambiar variables
  \item \function{select()} -- elegir un subconjunto de columnas
  \item \function{filter()} -- elegir un subconjunto de filas
  \item \function{summarise()} -- reducir todos los datos en el conjunto de datos a una fila de resumen
  \item \function{arrange()} -- reordenar las filas
\end{enumerate}
Esto se vuelve especialmente poderoso cuando se combina con el sexto comando, \function{group_by()}.
\begin{enumerate}
  \setcounter{enumi}{5}
  \item \function{group_by()} --divide el data frame en diferentes subconjuntos
\end{enumerate}
Adicionalmente las funciones 
\function{inner_join()} y 
\function{left_join()} pueden ser 
utilizadas para combinar datos de múltiples data frames


\subsection{Agregando nuevas variables a un data frame.}

La función \function{mutate()} puede ser usada para agregar o modificar variables en un data frame.
\Note{\function{mutate()} ingresa otras variables en el data frame, incluyendo cualquiera creada anteriormente en el mismo comando \function{mutate()}.}


Aquí mostramos cómo modificar el data frame de \dataframe{Births78} para que contenga una nueva variable, \variable{weekend}(fin de semana), que distingue entre los días entre semana y los fines de semana.
<<Births-make,fig.width=6,out.width=".8\\textwidth", tidy=FALSE>>=
data(Births78)
weekdays <- c("Sun", "Mon", "Tue", "Wed", "Thr", "Fri", "Sat") 
Births <- 
  Births78 %>%
  mutate(weekend = wday %in% c("Sat", "Sun"))

head(Births, 3)
@


<<Births-plot,fig.width=6,out.width="\\textwidth", tidy=FALSE>>=
xyplot(births ~ date, Births, groups=weekend, auto.key=list(space='right'))
@

\marginnote{Número de nacimientos en Estados Unidos en 1978 coloreado por día de la semana.}

%If we save \dataframe{Births} using \function{write.csv()}, we will lose the ordering 
%of the days.  (The default order when reading the csv file is alphabetical.)
%If we use \function{save()} instead, the natural order of the days is preserved.
%<<Births-save>>=
%save(Births, file="Births.rda")
%load("Births.rda")
%tally(~day, Births)  # note order of days
%@



El conjunto de datos \dataframe{CPS85} contiene datos de la Encuesta Actual de Población (actual en 1985, es eso). Dos de las variables en este data frame son \variable{age} y \variable{educ}. Podemos estimar el número de años que un a trabajador ha estado en la fuerza de trabajo si asumimos que ha estado en la fuerza de trabajo desde que terminó la su educación, y su edad de graduación es 6 más el número de años de educación obtenida.
<<>>=
CPS85 <- mutate(CPS85, workforce.years = age - 6 - educ)
favstats( ~ workforce.years, data=CPS85)
@

%In fact this is what was done for all but one of the cases to create the \variable{exper} 
%variable that is already in the \dataframe{CPS85} data.
<<>>=
tally( ~ (exper - workforce.years), data=CPS85)
@

Con una variable categórica, en ocasiones queremos modificar el esquema de código
<<tidy=FALSE>>=
HELP2 <- mutate(HELPrct, 
  newsex = factor(female, labels=c('M','F')))
@
Es una buena idea hacer algún tipo de control de sanidad para asegurarse que la recodificación funcionó de acuerdo a su intención.
<<>>=
tally( ~ newsex + female, data=HELP2)
@

La función \function{derivedFactor()} puede simplificar crear factores basado en algunas pruebas lógicas.


<<tidy=FALSE>>=
HELP3 <- mutate(HELPrct, 
  risklevel = derivedFactor(
    low = sexrisk < 5, 
  medium = sexrisk < 10,
	high = sexrisk >=10,
	.method = "first"      # use first rule that applies
	)
)
@
\begin{widestuff}
<<echo=FALSE>>=
OLD <- options(width=90)
@
<<>>=
head(HELP3, 4) 
@
<<echo=FALSE>>=
options(OLD)
@
\end{widestuff}
%
%\newthought{character variables}
%stuff here 
%
%\newthought{coercing variables}
%stuff here 
%
%\newthought{recoding variables}
%stuff here 

\subsection{Desechando variables}

\label{sec:dropping}

\Rindex{select()}%
Puesto que ya tenemos \variable{educ}, no tenemos razones para dejarnos nuestra nueva variable 
\variable{workforce.years}. Desechemosla. 
Note el uso inteligente del signo de menos.
<<>>=
CPS1 <- select(CPS85, -workforce.years)
head(CPS1, 1)
@
\DiggingDeeper{Los programadores profesionales en \R, así como Hadley Wickham, el autor del paquete \pkg{dplyr}, toman como ventaja una característica especial del lenguaje que permite que la notación del menos signifique "excluir".}

Cualquier número de variables pueden ser desechadas o se pueden mantener de esta forma supliendo un vector de nombres de variables.
<<>>=
CPS1 <- select(CPS85, c(workforce.years,exper))
@
Las columnas pueden especificarse por número, así como por nombre (esto puede ser peligroso si está equivocado sobre dónde están las columnas).
<<>>=
CPSsmall <- select(CPS85, select=1:4)
head(CPSsmall,2)
@
Las funciones  
\function{matches()}, 
\function{contains()},
\function{starts_with()}, 
\function{ends_with()},
y  
\function{number_range()}
son funciones especiales que sólo funcionan en el 
contexto de \function{select} pero pueden ser útiles para 
describir conjuntos de variables o para mantenerlas o desecharlas.
\Rindex{matches()}%
\Rindex{contains()}%
\Rindex{starts_with()}%
\Rindex{ends_with()}%
\Rindex{number_range()}%

<<>>=
head(select(HELPrct, contains("risk")), 2)
@

La función anidada en el comando previo hace el código un poco más difícil de leer, y podría ser peor si estuviéramos utilizando algunas funciones más. El paquete magritt (que carga cada vez que dplyr carga, ergo, carga cada vez que mosaic carga) nos proporciona una alternativa para la sintaxis
<<>>=
HELPrct %>% select(contains("risk")) %>% head(2)
@
El operador \code{\%>\%} usa las salidas de la parte izquierda como la primera entrada para la función que está a la derecha. Esto hace sencillo encadenar varios comandos de manipulación de datos en el orden que se aplican a los datos sin tener que anidar con mucho cuidado los paréntesis, y sin tener que pasar salidas de una función como un argumento para la próxima.

Aquí hay unos cuantos ejemplos más:
<<>>=
HELPrct %>% select(ends_with("e"))   %>% head(2)
HELPrct %>% select(starts_with("h")) %>% head(2)
HELPrct %>% select(matches("i[12]")) %>% head(2)  # regex matching
@

\subsection{Renombrando las variables}
Ambos, los nombres de la columna (variables) y los nombres de la fila de un conjunto de datos pueden ser cambiadas por un simple asignamiento, usando \function{names()} o \function{row.names()}.
<<>>=
ddd         # Datos pequeños que definimos antes
#Cambiar el nombre de las filas afecta como se imprime el data frame
row.names(ddd) <- c("Abe","Betty","Claire","Don","Ethel")
ddd           
@
Es también posible ajustar un único nombre con la siguiente sintaxis.
<<>>=
#El nombre está mal escrito, arreglémoslo
row.names(ddd)[2] <- "Bette"
row.names(ddd)
@

El conjunto de datos \dataframe{faithful} (en el paquete \pkg{datasets}, que está siempre disponible) tiene unos nombres desafortunados.
<<>>=
names(faithful)
@
Las medidas son la duración de una erupción 
y el tiempo a la erupción posterior, 
entonces mejor se les da mejores nombres.
\TeachingTip{Una solución alternativa es usar el conjunto de datos \dataframe{geyser} en el paquete \pkg{MASS}. El data frame geyser tiene mejores nombres y más datos. Pero queremos ilustrar como reparar el daño en faithful.}
<<>>=
names(faithful) <- c('duration', 'time_til_next')
head(faithful, 3)
@

\begin{center}
<<faithful-xy>>=
xyplot(time_til_next ~ duration, faithful)
@

\end{center}

\marginnote[-1cm]{Si la variable que contiene un data frame es modificada o utilizada para guardar un objeto diferente, los datos originales del paquete se pueden recuperar usando \function{data()}.}

\begin{problem}
Usando el conjunto de datos \dataframe{faithful}, haga un gráfico de dispersión de la duración de la erupción contra el tiempo desde la última erupción..
\end{problem}

Podemos también renombrar una única variable usando \function{names()}. Por ejemplo, tal vez queremos renombrar \variable{educ}(la segunda columna) y ponerle educación.
<<>>=
names(CPS85)[2] <- 'educacion'
CPS85[1,1:4]
@

Si no sabemos el número de columna (o generalmente para hacer nuestro código más claro), un poco

<<>>=
names(CPS85)[names(CPS85) == 'education'] <- 'educ'
CPS85[1,1:4]
@

%\FoodForThought{See Section \ref{sec:dropping} for information that will make 
%it clearer what is going on here.}

La función \function{select()} también se puede usar para renombrar variables.
<<tidy=FALSE>>=
data(faithful)    #restaura la versión original
faithful2 <- faithful %>% 
  select(duration=eruptions, time_til_next = waiting)
head(faithful2, 2)
@


\subsection{Creando subconjuntos}
\label{sec:subsets}
Podemos usar \function{filter()} para elegir 
solamente algunas filas de nuestro conjunto de datos.
\begin{center}
<<faithful-long-xy>>=
#Cualquier estructura lógica puede ser utilizada para crear subconjuntos
faithful2 %>% filter(duration > 3) -> faithfulLong 
xyplot(time_til_next ~ duration, faithfulLong)
@

\end{center}


Si lo único que queremos es producir un gráfico y no necesitamos guardar el subconjunto, el gráfico mostrado anteriormente también puede ser construido de cualquiera de las siguientes formas
<<eval=FALSE, tidy=FALSE, fig.keep="last", fig.show="hide">>=
xyplot(time_til_next ~ duration, 
       data = faithful2 %>% filter(duration > 3))
xyplot(time_til_next ~ duration, data = faithful2, 
       subset=duration > 3)
@

\subsection{Resumiendo un conjunto de datos.}

La función \function{summarise()} (o \function{summarize()}) resume un conjunto de datos en una única fila.
<<>>=
HELPrct %>% summarise(x.bar = mean(age), s=sd(age))
@

Esto es especialmente útil en conjunto con \function{group_by()}, que divide los conjuntos de datos en subconjuntos. El siguiente comando va calcular la media y desviación estándar para cada sub-grupo definido por una diferente combinación de sexo y sustancia.
<<tidy=FALSE>>=
HELPrct %>% group_by(sex, substance) %>%
  summarise(x.bar = mean(age), s=sd(age))
@
Este resumen numérico basado en funciones que proporciona el paquete \pkg{mosaic} es probablemente más fácil para esta tarea particular, pero usar \pkg{dplyr} es más general.

\begin{widestuff}
<<echo=FALSE>>=
OLD <- options(width=110)
@
<<results='hide',eval=FALSE>>=
favstats(age ~ sex + substance, data=HELPrct, .format="table")
@
<<echo=FALSE>>=
favstats(age ~ sex + substance, data=HELPrct) %>% data.frame
@
<<results='hide',eval=FALSE>>=
mean(age ~ sex + substance, data=HELPrct, .format="table")
@
<<echo=FALSE>>=
mean(age ~ sex + substance, data=HELPrct) -> foo
foo <- data.frame(group=names(foo), mean=foo)
row.names(foo) <- NULL
foo
@

<<results='hide',eval=FALSE>>=
sd(age ~ sex + substance, data=HELPrct, .format="table")
@
<<echo=FALSE>>=
sd(age ~ sex + substance, data=HELPrct) -> foo
foo <- data.frame(group=names(foo), sd=foo)
row.names(foo) <- NULL
foo
@
<<echo=FALSE>>=
options(OLD)
@
\end{widestuff}

\newpage

\subsection{Organizando el data frame.}

En ocasiones es conveniente re-ordenar el conjunto de datos. Podemos hacer esto con la función \function{arrange()} especificándole en qué variables estamos haciendo la clasificación.

<<tidy=FALSE>>=
HELPrct %>% 
  group_by(sex, substance) %>%
  summarise(x.bar = mean(age), s=sd(age)) %>% 
  arrange(x.bar)
@

\enlargethispage{1in}
\subsection{Uniendo conjuntos de datos}

El conjunto de datos \dataframe{fusion1} en el paquete \pkg{fastR} contiene información del genotipo para un SNP (Polimorfismo de nucleotido solo) en el gen TCF7L2. El conjunto de datos \dataframe{pheno} contiene fenotipos (incluyendo el status de caso/control de diabetes tipo 2) para un conjunto cruzado de individuos. Podemos unir estos dos  conjuntos para explorar la asociación entre genotipos y fenotipos usando una de las funciones para juntar en \pkg{dplyr} o podemos usar la función \function{merge()}.

%\Rindex{merge()}%
\begin{widestuff}
<<echo=FALSE>>=
OLD <- options(width=90)
@
<<>>=
require(fastR)
fusion1 %>% head(3)
pheno %>% head(3)
@
\end{widestuff}

\begin{widestuff}
<<tidy=FALSE>>=
#Una unión entre fusion1 y pheno, manteniendo solo sus ids, que están en ambos
fusion1m <- merge(fusion1, pheno, by.x='id', by.y='id', 
                  all.x=FALSE, all.y=FALSE)
fusion1m %>% head(3)
@
<<echo=FALSE>>=
options(OLD)
@
\end{widestuff}

<<>>=
pheno %>% left_join(fusion1, by="id") %>% dim()
@
<<>>=
pheno %>% inner_join(fusion1, by="id") %>% dim()
@
<<>>=
#¿Cuales ids están solo en \dataframe{pheno}?
setdiff(pheno$id, fusion1$id)   
pheno %>% anti_join(fusion1, by="id") 
@


La diferencia entre un inner join y un left join es que el inner join sólo incluye filas del primer conjunto de datos que emparejan con el segundo, mientras el left join incluye todas las filas incluso si no tienen pareja en el segundo. En el ejemplo anterior, hay dos sujetos en pheno que no aparecen en fusion1.

\function{merge()} maneja estas distinciones con los argumentos \option{all.x} o \function{all.y}. En este caso, puesto que los valores son el mismo para cada conjunto de datos, podemos colapsar \option{by.x} y \option{by.y} y colapsar \option{all.x} y \option{all.y} a \option{all}. La primera de estas específica cual(es) columna(s) usa para identificar los casos emparejados. El segundo indica si los casos en un conjunto de datos que no aparecen en el otro conjunto se deben quedar (\code{TRUE}) o se deben desechar (llenando con \code{NA} si se necesita) o desechados del conjunto de datos que se unió.

Ya estamos listos para iniciar nuestro análisis
<<fusion1-xtabs>>=
tally( ~ t2d + genotype + marker, data=fusion1m)
@

\begin{problem}
El conjunto de datos \dataframe{fusion2} en el paquete \pkg{fastR} 
contiene genotipos de otro SNP. Mezcle \dataframe{fusion1}, \dataframe{fusion2} y \dataframe{pheno} en un único conjunto de datos.

Note que \dataframe{fusion1} y \dataframe{fusion 2} tienen las mismas columnas

\begin{widestuff}
<<>>=
names(fusion1)
names(fusion2)
@
\end{widestuff}

Usted puede querer usar el argumento \option{suffixes} en \function{merge()} o renombrar las variables después de terminar de mezclar para hacer más fácil navegar entre ellas.

Organice su data frame sacando columnas que son 
redundantes o que no quiere tener en el conjunto de datos final.
\end{problem}


\section{Consiguiendo datos de bases de mySQL}

\Rindex{RMySQL}%
\myindex{SQL}%
El paquete \pkg{RMySQL} permite acceder directamente a datos en bases de datos en MySQL y el paquete dplyr facilita procesar estos datos de la misma forma que datos para un data frame. Esto hace fácil trabajar con grandes conjuntos de datos almacenados en bases de datos públicas. El ejemplo a continuación consulta el buscador de genoma de la UCSC para encontrar todos los genes conocidos del cromosoma~1.
\BlankNote{UCSC --- Universidad de California, Santa Cruz}%


\begin{widestuff}
<<echo=FALSE, include=FALSE>>=
library(RMySQL)
OLD <- options(width=100)
@

<<tidy=FALSE, message=FALSE,warning=FALSE>>=
#Conectándose a las bases de datos de la UCSC
require(dbplyr)
library(RMySQL)
UCSCdata <- src_mysql(
  host="genome-mysql.soe.ucsc.edu",
  user="genome",
  dbname="mm9")
# Tome alguna de todas las tablas en la base de datos
KnownGene <- tbl(UCSCdata, "knownGene")

#Consiga el nombre del gen, cromosoma, empiece y termine sitios 
#para genes en cromosoma 1
Chrom1 <-
  KnownGene %>% 
  select(name, chrom, txStart, txEnd) %>%
  filter(chrom == "chr1")
@
<<echo=FALSE>>=
options(OLD)
@
\end{widestuff}

\Rindex{src_mysql}
\Rindex{tbl}
Lo que resulta de \dataframe{Chrom1} no es un conjunto de datos en forma de tabla de datos pero se comporta mucho como uno.
<<>>=
class(Chrom1)
@
\Rindex{mutate()}
\Caution[3cm]{Las operaciones aritméticas en el comando \function{mutate()} en este caso son ejecutadas en SQL, no en \R, por ende la gama de funciones que permite es más pequeña. No es posible, por ejemplo, ejecutar un logaritmo para todos usando \function{log()}. Para eso, primero debemos guardar la base en un data frame real.}
<<warning=FALSE>>=
Chrom1 %>% 
  mutate(length=(txEnd - txStart)/1000) -> Chrom1l
Chrom1l
@

Para la eficiencia, todos los datos no son sacados de la base de datos hasta que sean necesarios (o hasta que se lo pidamos usando \function{collect()}). Esto nos permite, por ejemplo, inspeccionar las primeras filas de una potencial salida gigante de la base de datos sin en realidad haber hecho el trabajo requerido para sacar esos datos.


Pero ciertas cosas no funcionan a menos que juntemos los resultados de la base de datos en un data frame. Para hacer un gráfico de los datos usando \pkg{lattice} o \pkg{ggplot2}, por ejemplo, primero tenemos que usar \function{collect()} para juntarlo en un data frame.
\Rindex{collect()}
<<tidy=FALSE, warning=FALSE>>=
Chrom1df <- collect(Chrom1l)       # collect into a data frame
histogram( ~ length, data=Chrom1df, xlab="gene length (kb)")
@


%A great example of this is the 12 gigabytes of data from the Airline on-time
%performance dataset included in the 2009 Data Expo (\url{http://stat-computing.org/dataexpo/2009}).
%There is an \href{http://csg.sph.umich.edu/docs/R/rsql.html}{online document}
%describing this type of manipulation.

\section{Dándole nueva forma con \texttt{tidyr}.}

\Rindex{tidyr}
En ocasiones los datos vienen en una forma que no va de acuerdo a nuestros propósitos. El paquete \pkg{tidyr} incluye algunas funciones para organizar los datos, incluyendo \function{spread()} y \function{gather()}, que puede ser utilizado para convertir entre formatos ``largos" y ``anchos". Podemos querer saber esto por un cambio en la perspectiva sobre lo que la unidad de observación es, por ejemplo. Por ejemplo en el conjunto de datos \dataframe{traffic}, cada fila es un año y los datos, y los datos para multiples estados son proporcionados

<<traffic-reshape>>=
traffic
@

Podemos re-formatear esto de tal forma que cada fila contenga la medida para un único estado en un año juntando los estados en columnas.

<<tidy=FALSE>>=
require(tidyr)
LongTraffic <- 
  traffic %>% 
  select(-cn.deaths) %>%
  gather(state, death.rate, ny:ri)
head(LongTraffic)
@

Este formato largo nos permite crear gráficos como este.
<<>>=
xyplot(death.rate ~ year, data = LongTraffic, groups = toupper(state), 
       type = "l", 
       auto.key = list(space = "right", lines = TRUE, points = FALSE))
@

Podemos también reformatearlo de la otra forma, en esta ocasión teniendo todos los datos de un estado en una fila de la matriz de datos.

\begin{widestuff}
<<echo=FALSE>>=
OLD <- options(width=100)
@
<<tidy=FALSE>>=
StateTraffic <- 
  LongTraffic %>%
  spread(state, death.rate)
StateTraffic %>% head(3)
@
\noindent
Podemos crear un gráfico usando este formato de datos también, 
pero implica una notación de 
fórmula que no hemos visto antes:
<<>>=
xyplot(ri + ny + cn + ma ~ year, data=StateTraffic, type = "l",
       auto.key = list(space = "right", lines = TRUE, points = FALSE))
@

<<echo=FALSE>>=
options(OLD)
@
\end{widestuff}



%\subsection{Simple Relational Database Operations}
%
%\newthought{Example: Grades/Courses}
%
%Using the grade/courses database, show how to combine data from
%different data frames. [DTK]

%\newthought{Example: Merging Genotype and Phenotype Data}
%\label{example:fusion1-glm1}%
%\myindex{FUSION|exampleidx}%
%\myindex{logistic regression}%


\section{Funciones en \R} %{An introduction to writing functions}
\label{sec:writingFunctions}
\label{sec:functions}
\myindex{functions in {\sf R}}%

%To really customize a &lattice& plot -- and for many other applications in \R\ -- 
%you need to learn how to use the &panel& argument,
%which means you need to learn how to write functions.
Las funciones en R tienen algunos componentes:
\begin{itemize}
  \item un \rterm{nombre} (como \code{histogram})\footnote{En realidad, es   posible llamar funciones sin utilizar su nombre; 
  y para funciones pequeñas que sólo se necesitan una vez, esto puede ser útil}
  \item
  Una lista ordenada de \term{argumentos}, que sirven como entradas de la función.
	\myindex{argument of an R function@argument of an {\sf R} function}%

	Estas son emparejadas primero por nombre y después por el orden que se le da 
	a los valores en la llamada de la función. Esta es la razón por la cual 
	no siempre incluimos el nombre del argumento en los llamados de la función. 
	Por otro lado, la disponibilidad de los nombres significa que no tenemos 
	que recordar el orden en el cual el argumento es listado.

	Los argumentos usualmente tienen \rterm{valores predeterminados} que son 
	utilizados si no se le da ningún valor al llamado de la función.
  \item
	Un \rterm{valor de salida} 

	Es la salida de la función, puede ser asignado a una variable usando 
	el operador de asignación (\code{=}, \code{<-}, o \code{->}).
	\Rindex{->}%
	\Rindex{<-}%
	\Rindex{=}%

  \item
	\rterm{Efectos secundarios}
	
	Una función puede hacer otras cosas (como hacer un gráfico o ajustar 
	algunas preferencias) que no son necesariamente parte del valor de salida

\end{itemize}
Cuando se lee la documentación de ayuda para una función de \R, va poder ver que está organizada en secciones que están relacionadas a estos componentes. La lista de argumentos aparece en la sección de Usage con otros valores predeterminados. Los detalles sobre cómo los argumentos suelen aparecen en la sección de \rterm{Arguments} (argumentos). El valor de salida en la sección de \rterm{Value} (valor). Cualquier efecto secundario usualmente es mencionado en la sección de \rterm{Details}.  
\marginnote{Incluso si usted no termina escribiendo muchas funciones por su cuenta, escribir una función le va dar muchísima mejor percepción de como la información fluye en el código de \R.}

Ahora intentemos escribir nuestra propia función. Suponga que frecuentemente desea calcular la media, mediana y desviación estándar de una distribución. Puede hacer una función que nos ayude a ahorrar un poco de escritura

Ahora nombremos nuestra función \function{mystats()}. La función \function{mystats()} va tener sólo un argumento, que asumimos que va tener un vector de valores numéricos.%
\Rindex{mystats()}%
\Rindex{function()}%
 Aquí está como la podemos definir: 
\Rindex{mystats()}%

<<defFun01>>=
mystats <- function(x) {
    mean(x)
    median(x)
    sd(x)
}
@

<<>>=
mystats((1:20)^2)
@

\marginnote[-2cm]{Siempre hay formas de revisar la \rterm{clase} de un argumento, para ver si es un data frame, un vector, numérica, etc. Una función robusta debería revisar que los valores que se entregan a los argumentos son del tipo apropiado}%

La primera línea dice que estamos definiendo una función llamada \function{mystats()} con un argumento, llamado \variable{x}. Las líneas dentro de los paréntesis de llave le dicen al código que sea ejecutado cuando la función es llamada. Entonces, nuestra función computa la media, después la mediana y después la desviación estándar.

But as you see, this doesn't do exactly what we wanted.  So what's going on?   The value returned by the last line of a function is (by default) returned by the function to its calling environment, where it is (by default) printed to the screen so you can see it.  In our case, we computed the mean, median, and standard deviation, but only the standard deviation is being returned by the function and hence displayed.  So this function is just an inefficient version of \function{sd()}.  That isn't really what we wanted.

Podemos usar \function{print()} para imprimir cosas en el camino si queremos


<<defFun02>>=
mystats <- function(x) {
    print(mean(x))
    print(median(x))
    print(sd(x))
}

mystats((1:20)^2)
@


Alternativamente, podemos usar una combinación de \verb!cat()! and \verb!paste()!, que nos va dar más control sobre como la salida es desplegada.
\Rindex{cat()}%
\Rindex{paste()}%

<<defFun02-cat>>=
altmystats <- function(x) {
    cat(paste("  mean:", format(mean(x),4),"\n"))
    cat(paste(" edian:", format(median(x),4),"\n"))
    cat(paste("    sd:", format(sd(x),4),"\n"))
}
altmystats((1:20)^2)
@
Cualquiera de estos métodos va permitirnos ver tres valores, pero si intentamos guardarlos\dots
%\authNote{Talk about \function{paste()} some more somewhere?}%

<<defFun02a>>=
temp <- mystats((1:20)^2)
temp
@
Una función de \R\ puede solamente tener un valor de salida, y predeterminadamente es el valor de la última línea en la función. En el ejemplo anterior sólo tenemos la desviación estándar puesto que es el último valor que se calculó.

Nos gustaría que la función nos de los 3 estadísticos de resumen. Nuestra solución va ser guarda todos los tres en un vector y que nos de ese vector.%
\footnote{Si los valores no están todos en la misma clase, podemos usar una lista.}

<<defFun03>>=
mystats <- function(x) {
	c(mean(x), median(x), sd(x))
}
mystats((1:20)^2)
@

\enlargethispage{1in}

Ahora el único problema es que si tenemos que recordar cual número es cual. Podemos arreglarlo dándole nombres a los espacios en nuestros vectores. Mientras estamos en eso, agreguemos un poco más de resúmenes favoritos a la lista. Además agreguemos explícitamente un \function{return()}.
\Rindex{return()}%

\begin{widestuff}

<<defFun04>>=
mystats <- function(x) {
    result <- c(min(x), max(x), mean(x), median(x), sd(x))
    names(result) <- c("min","max","mean","median","sd")
    return(result)
}
mystats((1:20)^2)
aggregate(Sepal.Length ~ Species, data=iris, FUN=mystats)
@

\end{widestuff}

Note lo bien que esto trabaja con \function{aggregate()}.
\Rindex{favstats()}%
La función \function{favstats()} en el paquete mosaic incluye los cuartiles, la media, la desviación estándar, el tamaño de muestra y el número de observaciones faltantes

\begin{widestuff}
<<echo=FALSE>>=
OLD <- options(width=100)
@
<<>>=
favstats(Sepal.Length ~ Species, data=iris)
@
<<echo=FALSE>>=
options(width=60)
@
\end{widestuff}
Podemos conseguir una versión de nuestra nueva función que trabaje con la notación de fórmula como esta
<<>>=
#Primero creamos una versión que trabaje con vectores
mystats_ <- function(x, na.rm = TRUE) {
    result <- c(min(x, na.rm = na.rm), max(x, na.rm = na.rm), mean(x, na.rm = na.rm), 
                median(x, na.rm = na.rm), sd(x, na.rm = na.rm))
    names(result) <- c("min","max","mean","median","sd")
    return(result)
}
#Ahora creemos una versión que conozca nuestra notación de fórmula
mystats <- aggregatingFunction1(mystats_, output.multiple = TRUE)

mystats(Sepal.Length ~ Species, data = iris)
@


%\authNote{rjp to add a section here showing how to start with a code chunk 
%and make it reusable by wrapping it up into a function.}

%\iffalse
%\section{A Few Graphical Bells and Whistles}
%There are lots of arguments that control how lattice plots look.  Here are just a few examples.

%\newthought{auto.key}
%When using overlayed groups in a plot, it is often useful to 
%have a legend.  \verb!auto.key=TRUE!  turns on a simple legend.  
%(There are ways to have more control, if you need it.)
%<<iris-xyplot-key,cache=TRUE,tidy=FALSE>>=
%xyplot(Sepal.Length ~ Sepal.Width, groups=Species, 
%    data=iris, auto.key=TRUE)   
%@

%\newthought{alpha, cex}
%Sometimes it is nice to have elements of a plot be partly transparent.  When such elements overlap, they get darker, showing us where data are ``piling up." Setting the \verb!alpha! argument to a value between 0 and 1 controls the degree  of transparency: 1 is completely opaque, 0 is invisible.
%The \verb!cex! argument controls ``character expansion" and can be used to make the plotting ``characters" larger or smaller by specifying the scaling ratio.
%<<iris-xyplot-alpha,cache=TRUE,tidy=FALSE>>=
%xyplot(Sepal.Length ~ Sepal.Width, data=iris, 
%    groups=Species, 
%    auto.key=list(columns=3),
%    alpha=.5, cex=1.3)   
%@

%\vspace{-8mm}
%\newthought{main, sub, xlab, ylab}

%You can add a title or subtitle, or change the default labels of the axes.
%<<iris-xyplot-text,cache=TRUE,tidy=FALSE>>=
%xyplot(Sepal.Length ~ Sepal.Width, groups=Species, data=iris, 
%    main="Some Iris Data",
%    sub="(R. A. Fisher analysed these data in 1936)",
%    xlab="sepal width (cm)",
%    ylab="sepal length (cm)",
%    alpha=.5,        
%    auto.key=list(columns=3))   
%@

%\newthought{trellis.par.set()}
%Default settings for lattice graphics are set using 
%\verb!trellis.par.set()!.
%Don't like the default font sizes?  You can change to a 7 point (base) font using

%<<fontsize,eval=TRUE>>=
%# set the base size for text to 7 point 
%trellis.par.set(fontsize=list(text=7))    
%@

%Nearly every feature of a lattice plot can be controlled: fonts, colors, symbols, line thicknesses, colors, etc. Rather than describe them all here, we'll mention only that groups of these settings can be collected into a theme.  \verb!show.settings()! will show you what the theme looks like.

%<<themes-whitbg,cache=TRUE,fig.height=4.0,fig.width=6>>=
%# a theme in the lattice package
%trellis.par.set(theme=col.whitebg())      
%show.settings()
%@

%<<themes-mosaic,cache=TRUE,fig.height=4,fig.width=6>>=
%# a theme in the mosaic package
%trellis.par.set(theme=col.mosaic())        
%show.settings()
%@
%\SuggestionBox{Do you have a great eye for colors?  Help us design other 
%lattice themes.}%

%\DiggingDeeper{The \pkg{RColorBrewer} package provides several palettes of colors that are highly distinguishable and aesthetically pleasing.}%
%<<themes-mosaicbw,cache=TRUE,fig.height=4,fig.width=6>>=
%# black and white version of previous theme
%trellis.par.set(theme=col.mosaic(bw=TRUE)) 
%show.settings()
%@

%<<themes-mosaic-redo>>=
%# back to the mosaic theme
%trellis.par.set(theme=col.mosaic())       
%# and back to a larger font 
%trellis.par.set(fontsize=list(text=9))    
%@

%\begin{problem}
%The \verb!Jordan8687! data set (in the \verb!fastR! package) contains the number of points Michael Jordan scored in each game of the 1986--87 season.  
%\begin{enumerate}
%item
%Make a histogram of this data.  Add an appropriate title.
%\item
%How would you describe the shape of the distribution?
%\item
%In approximately what percentage of his games, did Michael Jordan score less than 20 points? More than 50? (You may want to add \verb!breaks=seq(0,70,by=5)! to your command to neaten up the bins.)
%\end{enumerate}
%\end{problem}

%\begin{problem}
%Cuckoos lay their eggs in the nests of other birds.  Is the size of cuckoo eggs different in different host species nests?  The \verb!cuckoo! data set (in \verb!fastR!) contains data from a study attempting to answer this question.
%\begin{enumerate}
%\item
%When were these data collected?  (Use \verb!?cuckoo! to get information about the data set.)
%\item
%What are the units on the length measurements?
%\item
%Make side-by-side boxplots of the length of the eggs by species.
%\item
%Calculate the mean length of the eggs for each host species.
%\item
%What do you think?  Does it look like the size is differs among the different host species?  Refer to your \R\ output as you answer this question. (We'll learn formal methods to investigate this later in the semester.)
%\end{enumerate}
%\vspace{-5mm}
%\end{problem}

%\fi


%\subsection{Accounting for missing data}

\section{Compartiendo con y entre sus estudiantes}
\label{sec:distributing-data}

Los instructores en varias ocasiones tienen sus propios conjuntos de datos para ilustrar puntos de interés estadístico o para hacer una conexión particular con la clase. En ocasiones se puede querer que la clase construya un conjunto de datos, llenando un cuestionario o contribuyendo con pequeñas partes para una colección de datos de la clase. Los estudiantes pueden estar trabajando en proyectos de grupos pequeños; es agradable tener herramientas que apoyen este trabajo de tal forma que los miembros de grupos tengan acceso los datos y puedan contribuir a los reportes escritos.

Hay ahora muchas tecnologías que apoyan esta forma de compartir. Por el bien de la simplicidad, vamos a enfatizar tres que hemos encontrado particularmente útiles, tanto en la enseñanza de la estadística como en nuestro trabajo profesional colaborativo. Estos son:
\begin{itemize}
\item Un sitio web, como Dropbox 
\item El servicio de Google Docs. .
\item Un servidor basado en la web de \RStudio.
\end{itemize}
Los primeros dos ahora son muy utilizados en el ambiente universitario y son accesibles simplemente mediante el ajuste de una cuenta. Ajustar un servidor de \RStudio\ requiere algún soporte de IT, pero las habilidades de IT necesarios están en el rango de habilidades necesarias se pueden encontrar en algunos sujetos en las oficinas de IT de la facultad..

\subsection{Usando el servidor de \RStudio\ para compartir documentos}
\TeachingTip[-3cm]{Cuando las cuentas ya están ajustadas en un servidor de RStudio para una nueva clase en Calvin, a cada usuario se le entrega una dirección simbólica con acceso a un directorio donde el instructor puede escribir documentos y los estudiantes únicamente pueden leer los documentos. Esto proporciona una forma sencilla de hacer datos, código de \R, o historiales disponibles para estudiantes desde \RStudio.}

El servidor de \RStudio\ se ejecuta desde una máquina con Linux. Los usuarios de \RStudio\ tienen cuentas bajo el sistema de archivos de Linux y es posible ajustar directorios compartidos con permisos para que múltiples usuarios puedan leer y/o escribir archivos y los guarden ahí. Esto tiene que estar hecho afuera de \RStudio, pero si está familiarizado con el sistema operativo Linux o tiene un administrador de sistema dispuestos a ayudarlo, no es difícil de hacer.


\subsection{Su propio sitio web}

Puede ser que ya tengan un sitio web. Tenga en mente un lugar donde puede poner archivos y que se pueda acceder a estos directamente de internet. Para compartir datos, es mejor que este sitio sea público, esto significa, que no requiera un inicio de sesión para que otros accedan a los documentos que usted sube. En este caso, \function{read.file()} puede leer los datos de R directamente de la siguiente URL:
<<out.width=".5\\textwidth">>=
Fires <- read.csv("http://www.calvin.edu/~rpruim/data/Fires.csv")
head(Fires)
xyplot(Acres/Fires ~ Year, data=Fires, ylab="acres per fire",
        type=c("p","smooth"))
@

%\authNote{Need to check whether Dropbox workflow is still correct. --rjp 2014-06-28}
\index{Dropbox}
Desafortunadamente, la mayoría de nuestros sistemas de "apoyo de cursos" como Moodle o Blackboard no proporcionan una forma tan sencilla de acceder a datos. El sistema de Dropbox para guardar datos en una "nube" brinda una forma muy conveniente de distribuir archivos por la web. (Diríjase a \texttt{dropbox.com} para información y para inscribirse con una cuenta gratuita.) Dropbox es rutinariamente utilizado para proporcionar respaldo y acceso a archivos coordinado en múltiples computadoras. Sin embargo, el servicio de Dropbox también ofrece un directorio público. Se puede acceder a cualquier archivo que usted suba directamente desde la URL 
\FoodForThought{Nuestra discusión de Dropbox es primariamente para aquellos que no saben hacer esto de otra forma.}%

Para ilustrarlo, suponga que usted desea compartir algunos conjuntos de datos con sus estudiantes. Ya ha construido este en una hoja de Excel y la ha guardado en un archivo .csv, llamémoslo \code{ejemplo-A.csv}. Mueva este documento al directorio \code{Público} en Dropbox - en la mayoría de computadoras Dropbox ordena las cosas de tal forma que los directorios aparezcan exactamente como los directorios ordinarios y usted puede usar las técnicas familiares de manejo de datos, como mover los datos seleccionándolos y poniéndolos en otro lugar


\begin{center}
\includegraphics[width=3.5in]{images/dropbox1.png}
\end{center}
\marginnote[-2cm]{Dragging a csv file to a Dropbox Public directory}

Dropbox también hace sencillo construir un URL identificador localizado en la web, para cualquier archivo, mediante el uso del mouse con comandos de menú para que pueda ponerse en una URL en el clipboard, en donde puede ser copiada en el software de apoyo del curso o cualquier otro lugar para la distribución a los estudiantes.



<<read-quoted-URL, eval=FALSE>>=
a <- read.file("http://dl.dropbox.com/u/5098197/USCOTS2011/ExampleA.csv")
@ 

%\InstructorNote{The history feature in \RStudio\ can be used to 
%re-run this command in future sessions.}

\begin{center}
\includegraphics[width=.9\textwidth]{images/dropbox2.png}
\end{center}
\marginnote[-1cm]{Getting the URL of a file in a Dropbox Public directory}

Esta técnica hace sencillo distribuir datos con muy poca preparación. Es lo suficientemente rápido como para hacerlo en media clase: el archivo csv está disponible para sus estudiantes (después de un poco de atraso mientras Dropbox se sincroniza). Puede incluso ser editado por usted (pero no por sus estudiantes).

La misma técnica puede ser aplicada a cualquier tipo de documento como entornos de R o scripts de R (archivos que contienen código). Por supuesto, sus estudiantes necesitan usar adecuadamente el comando de \R: \function{load()} para un entorno y \function{source()} para un script.

%\authNote{RP: Not sure workspace is the best word for this.}

El ejemplo anterior le consigue un archivo que imprime un mensaje de bienvenida para usted.
<<source-example>>=
source('http://mosaic-web.org/go/R/hello.R')
@

Pero usted puede poner cualquier código que quiera en los archivos que va hacer que sus estudiantes consigan. Puede instalar y cargar paquetes, recuperar o modificar conjuntos de datos, definir nuevas funciones o cualquier otra cosa que \R\ permita.

Muchos instructores encuentran útil crear un archivo con sus scripts de \R\ para el curso, agregando cosas y modificándolo conforme el curso progresa. Esto le permite distribuir todo tipo de función para propósitos especiales, permitiendo distribuir material de \R\ nuevo a sus estudiantes. Esa idea brillante que tuvo a las 2 AM puede ser programada y puesta para que los estudiantes lo usen en la clase de la mañana siguiente. Luego, conforme identifica errores y refina la programación, puede hacer el software actualizado inmediatamente disponible para los estudiantes.

\Caution{La seguridad de este tipo no va satisfacer las regulaciones de protección de datos institucionales ni los requerimientos éticos profesionales, entonces nada verdaderamente sencillo o confidencial debe ser "protegido" de esta forma.}%
Si la privacidad es una preocupación, puede que quiera datos sólo para sus estudiantes, puede efectivamente lograr esto dándole a los archivos nombres que sólo conozcan sus estudiantes, e.g., \code{Example-A78r423.csv}.


\subsection{GoogleDocs}
%\authNote{NH wants to add something about RMarkdown in this section, but I'm not 
%sure what he wants to add --rjp  2014--6-28}

La técnica de Dropbox (o cualquier otro sistema de publicación en el internet) es una excelente idea para la difusión: Tomar documentos que creó y distribuirlos en una forma de solo-lectura para sus estudiantes. Pero cuando se quiere compartir un documento en dos vías o más, otras técnicas son necesarias, como la que proporciona el servicio GoogleDocs.

GoogleDocs permite a los estudiantes e instructores crear varias formas de documentos, incluyendo reportes, presentaciones y hojas de cálculo. (Además de crear documentos \emph{de novo}, Google también convierte los documentos en una variedad de formatos.)

Una vez en, el sistema de GoogleDocs, los documentos pueden ser editados \emph{simultáneamente} por múltiples usuarios en diferentes localizaciones. Pueden ser compartidos con individuos o grupos y publicado para vista sin restricción e incluso edición.


Para la enseñanza tiene una variedad de usos:
\begin{itemize}
  \item Los estudiantes trabajando en proyectos de grupos pueden todos 
  simultáneamente tener acceso al reporte conforme se escribe 
  y a los datos que se están generando por el grupo.
  \item Toda la clase se le puede dar acceso al conjunto de datos, 
  tanto para lectura como para escritura.
  \item El sistema de Google Forms puede ser utilizado para construir 
  cuestionarios, cuyas respuestas puede poblar una hoja de cálculo que 
  puede leer en RStudio por los creadores del cuestionario.
  \item Los estudiantes pueden "entregar" reportes y conjuntos de 
  datos copiando el link en un sistema de apoyo como Moodle o Blackboard, 
  o enviando el link.
  \item El instructor puede ingresar comentarios y/o correcciones 
  directamente en un documento.
\end{itemize}

Una técnica efectiva para organizar es trabajo de estudiantes y asegurar al instructor (como a otros evaluadores) a tener acceso a estos, es crear un directorio de Google para cada estudiante en su clase (Dropbox se puede usar de esta manera). Ajuste los permisos en el directorio para compartirla con cada estudiante. Cualquier cosa que él o ella ponga en el directorio estará inmediatamente disponible para el instructor. El estudiante también puede compartírselo a otro estudiante específico (erg., miembros de un proyecto de grupo).


Los datos pueden ser leídos directamente de las hojas de google usando el paquete \pkg{googlesheets}. 
Esto funcional mucho como \function{read_excel()} del paquete \pkg{readxl}.

\section{Notas adicionales del sintaxis de R}


\subsection{El texto y las comillas}

La mayoría de las veces, el texto en \R\ debe ser contenido en comillas singulares o dobles. Usualmente no importa cual use, a menos que quiera una forma de comillas o la otra \emph{adentro} de su texto. Después debe usar el otro tipo de comillas desde el principio hasta el final

<<quotes>>=
# La apostrofe dentro requiere comillas dobles alrededor del texto
text1 <- "Mary didn't come"            
#Aquí cambiamos las cosas
text2 <- 'Do you use "scare quotes"?'  
@


\section{Mensajes de error comunes y qué los causa}
\label{sec:error-messages}

\subsection{Error: Object not found}

\R\ reporta cuando un objeto no es encontrado y cuando no puede localizar un objeto con el nombre que ha usado. Comúnmente la razón de esto es un error de escritura. Esto es fácilmente corregido escribiendo de nuevo el nombre de la forma correcta.
<<>>=
histogram( ~ age, data=HELPrct)
@

Otra razón para un error de objeto no encontrado es usar textos sin comillas cuando estas son necesarias

<<noquotes-error,error=TRUE, eval=FALSE>>=
text3 <- hello
@

En este caso, \R\ está buscando por algún objeto llamado \variable{hello}, pero lo que queremos decir es que guarde los caracteres.
<<noquotes-error-fix,error=TRUE>>=
text3 <- "hello"
@

\subsection{Error: unexpected \dots}

Si mientras \R\ está procesando una declaración, se encuentra algo que no tiene sentido, lo reporta como "unexpected"(inesperado). Usualmente esto es resultado de un error de escritura --- como omitir una coma.

<<Intento de error, eval=FALSE, error=TRUE, tidy=FALSE, results='hide'>>=
c(1,2 3)
falta una coma
@
%En esta linea hay que hacer que imprima el error, pero no lo está imprimiendo.
\vspace*{-.55in}
<<echo=FALSE,include=FALSE>>=
c <- function(...) {
  stop('unexpected numeric constant in "c(1,2 3"')
}
@

<<error=TRUE,echo=FALSE,error=TRUE>>=
c()
@
<<include=FALSE>>=
rm(c)
@

\subsection{Error: object of type 'closure'  is not subsettable}
Lo siguiente produce un error si time no ha sido definido.
<<error=TRUE>>=
time[3]
@
Hay una función llamada \function{time()} en \R, entonces si usted no ha definido un vector por ese nombre, R va tratar de subdividir la función \function{time()}, lo cual no tiene mucho sentido. 

Typically when you see this error, you have a function in a place you don't mean to have a function. The message can be cryptic to new users because of the reference to a closure.

\subsection{Otros Errores}
Si encuentra otros errores que no puede descifrar, en ocasiones pegar el mensaje de error en una búsqueda de google va encontrar discusión sobre el error en un contexto en el cual estancó a alguien más.

\section{Repaso de comandos de \R}


Aquí hay un pequeño resumen de comandos introducidos este capítulo.

\begin{widestuff}
<<tidy=FALSE,results='hide',fig.keep='none'>>=
source("file.R")                                 
#Ejecuta los comandos de un archivo

x <- 1:10                                        
# crea un vector con los números de 1 a 10
M <- matrix(1:12, nrow=3)                        
# crea una matriz 3 x 4
data.frame(number = 1:26, letter=letters[1:26])  
# crea un data frame
@
\end{widestuff}

\begin{widestuff}
<<tidy=FALSE,results='hide',fig.keep='none'>>=
mode(x)                                   
#Devuelve la moda de un objeto de R
length(x)                                 
# Devuelve el tamaño de un objeto
dim(HELPrct)                              
# dimension de la matriz, el arreglo o data frame
nrow(HELPrct)                             
# número de filas
ncol(HELPrct)                             
# número de columnas
names(HELPrct)                            
# los nombres de las variables en el dataframe 
row.names(HELPrct)                        
# los nombres de las filas en el dataframe
attributes(x)                             
#devuelve los atributos de x
@
\end{widestuff}

\begin{widestuff}
<<tidy=FALSE,results='hide',fig.keep='none'>>=
toupper(x)                                
#pone mayúsculas
as.character(x)                           
#convierte a un vector de tipo caracter 
as.logical(x)                             
# convierte a valores lógicos
as.numeric(x)                             
# convierte a números
as.integer(x)                             
#convierte a enteros
factor(x)                                 
# convierte a factor [datos categóricos]
class(x)                                  
#devuelve la clase del objeto x
@
\end{widestuff}

\begin{widestuff}
<<tidy=FALSE,results='hide',fig.keep='none'>>=
smallPrimes <- c(2,3,5,7,11)              
# crea un vector numérico 
rep(1, 10)                                
# diez 1's
seq(2, 10, by=2)                          
#Números pares menores o iguales a 10
rank(x)                                   
#Rankea lo contenido en el objeto x
sort(x)                                   
#Devuelve los elementos de x ordenados
order(x)                                  
# x[order(x)] de forma ordenada con x
rev(x)                                    
#Devuelve los elementos de x en orden inverso
diff(x)                                   
# Devuelve las diferencias entre elementos consecutivos
paste("Group", 1:3, sep="")               
# lo mismo que c("Group1", "Group2", "Group3")
@
\end{widestuff}

\begin{widestuff}
<<tidy=FALSE,results='hide',fig.keep='none'>>=
write.table(HELPrct, file="myHELP.txt")          
# Escribir datos en un archivo 
write.csv(HELPrct, file="myHELP.csv")            
#Escribir datos en una archivo csv
save(HELPrct, file="myHELP.Rda")                 
#Guardar objetos en formato de R

modData <- HELPrct %>% mutate(old = age > 50)    
#Agregar una nueva variable al conjunto de datos
women <- HELPrct %>% filter(sex=='female')       
#Seleccione solamente las columnas especificadas
favs <- HELPrct %>% select(age, sex, substance)  
#Mantenga solo 3 columnas

trellis.par.set(theme=col.mosaic())             
#Elije el tema para los gráficos lattice
show.settings()                                 
# inspecciona el tema de lattice
@
\end{widestuff}

\section{Ejercicios}
%For these problems, create a single Word document containing all of your work.

\shipoutProblems

<<echo=FALSE,include=FALSE>>=
inRStudio <- FALSE    # only try manipulate things if in RStudio
opts_chunk$set( fig.path="figures/Manipulate-" ) 
set.seed(123)
@


\chapter{Siendo interactivo: \texttt{manipulate} y \texttt{shiny}.}
\label{chap:manipulate}

Una característica muy atractiva de RStudio es la función \function{manipulate()} (en el paquete \pkg{manipulate} sólo disponible en \RStudio). Esta función hace más fácil crear una serie de controles (así como curvas, casillas de verificación, selecciones, etc.) que pueden ser utilizadas para cambiar dinámicamente valores dentro de una expresión. Cuando un valor es cambiado usando estos controles, la expresión es automáticamente re-ejecutada y los gráficos creados son un resultado del re-dibujo. Esto puede ser utilizado para rápidamente crear un prototipo de algunas actividades y demos que son parte de lecciones de estadística.

\pkg{shiny} es un sistema de desarrollo web nuevo para R, el cual es diseñado por el equipo de RStudio. shiny usa un modelo reactivo de programación para hacer relativamente fácil para un programador en \R\ 
crear aplicaciones web interactivas, bien diseñadas y usando 
\R\ sin necesidad de saber mucho acerca de 
programación web.  Programar en \pkg{shiny} es más enredado que usar manipulate, pero ofrece al diseñador más flexibilidad. Una de las metas al crear shiny fue apoyar ambientes corporativos, donde un pequeño número de estadísticos y programadores pueden crear aplicaciones web que 

puede ser utilizadas por otros en la compañía sin necesidad de saber \R. Esta misma idea también ofrece muchas posibilidades para propósitos educativos. Incluso algunos han aconsejado implementar una interfaces GUI bien extensas a funcionalidades comunes de R usando shiny.  

\section{Empezando con \texttt{manipulate}.}

La función \function{manipulate()} y las varias funciones de control que son utilizadas en esta función se pueden utilizar solamente después de cargar el paquete manipulate, que está solo disponible en RStudio

<<eval=inRStudio>>=
require(manipulate)
@


\subsection{Deslizadores}

<<manipulate-histogram1, echo=TRUE, tidy=FALSE, eval=inRStudio>>=
manipulate(
  histogram( ~ eruptions, data=faithful, n=N),
  N = slider(5,40)
)
@
\marginnote{Encontramos útil ponerle mayúsculas a las entradas con las que la expresión manipulada se va enganchar en los controles de \pkg{manipulate}. Esto ayuda a evitar choques con los nombres y las señales de cómo la expresión principal manipulada está siendo usada.} 
Esto genera un gráfico junto con un deslizador que tiene un rango de 5 a 40 para el número de clases (barras) 

\begin{center}
\includegraphics[width=3.8in]{images/manip-hist1.png}
\end{center}

Cuando movemos el deslizador, tenemos una mejor vista de las erupciones en \dataframe{Faithful}. 

\centerline{\includegraphics[width=3.8in]{images/manip-hist2.png}}

\newpage

\subsection{2 Revisar las cajas (poner una función de densidad}

<<manipulate-histogram2, tidy=FALSE, eval=inRStudio>>=
manipulate(
  histogram( ~ age, data=HELPrct, n=N, density=DENSITY),
  N = slider(5,40),
  DENSITY = checkbox()
)
@

\centerline{\includegraphics[width=3.8in]{images/manipulate-checkbox}}

\subsection{Menús}

Los menús pueden ser agregados usando la función \function{picker()}.

<<manipulate-histogram3, eval=inRStudio, tidy=FALSE>>=
manipulate(
    histogram( ~ age, data=HELPrct, n=N, 
                       fit=DISTRIBUTION, dlwd=4),
    N = slider(5,40),
    DISTRIBUTION = 
        picker('normal', 'gamma', 'exponential', 'lognormal',
               label="distribution")
)
@

\centerline{\includegraphics[width=3.8in]{images/manipulate-picker}}

\subsection{Visualizando la distribución normal}
\label{sec:vis-normal-dist}
En esta sección gradualmente vamos a construir un pequeño ejemplo de \pkg{manipulate} que muestra la flexibilidad que viene de escribir una función que nos da de vuelta un objeto \pkg{manipulate}. Estas funciones pueden ser distribuidas a los estudiantes para permitirles explorar interactivamente de una forma más flexible.

Empezamos por crear una ilustración de una cola de probabilidades en la distribución normal.
<<manipulate-xpnorm, tidy=FALSE, eval=inRStudio>>=
manipulate( 
    xpnorm( X, 500, 100, verbose=FALSE, invisible=TRUE ), 
    X = slider(200,800) )
@
\centerline{\includegraphics[width=3.8in]{images/manipulate-xpnorm}}
%
La versión anterior, puede ser utilizada también para investigar probabilidades centrales y de la cola.
<<manipulate-xpnorm2, eval=inRStudio, tidy=FALSE>>=
manipulate( 
    xpnorm( c(-X,X), 500, 100, verbose=FALSE, invisible=TRUE ), 
    X = slider(200,800) )
@

Estos ejemplos funcionan con una distribución fijada. Aquí hay una forma más fina en la cual la función devuelve un objeto de manipulate. Esto permite fácilmente crear ilustraciones como las anteriores para cualquier distribución normal.
<<eval=inRStudio, tidy=FALSE>>=
mNorm <- function( mean=0, sd=1 ) {
  lo <- mean - 5*sd 
  hi <- mean + 5*sd
  manipulate( 
    xpnorm( c(A,B), mean, sd, verbose=FALSE, invisible=TRUE ), 
    A = slider(lo, hi, initial=mean-sd), 
    B = slider(lo, hi, initial=mean+sd)
  )
}
mNorm( mean=100, sd=10 )
@

\section{\texttt{mPlot()}}

El paquete \pkg{mosaic} proporciona la función \function{mPlot()} que permite a los usuarios crear una amplia variedad de gráficos usando lattice o ggplot2. Después, el código utilizado para generar este gráfico puede ser desplegado si se le pide. Esto facilita aprender estos comandos, permite a los usuarios hacer modificaciones más allá, las cuales no son posibles con la interfaz de manipulate y proporciona un mecanismo de copiar-y-pegar para poner estos gráficos en otros documentos.

Los gráficos disponibles vienen en 3 opciones; si son de una variable, de dos o un mapa.

<<eval=FALSE>>=
# Estos son esencialmente gráficos de 2 variables
mPlot( HELPrct, "scatter" )            
# Empieza con un gráfico de dispersión
mPlot( HELPrct, "boxplot" )            
# Empieza con gráficos de barras
mPlot( HELPrct, "violin" )             
# Empiea con gráficos de violin
# Estos son esencialmente de una variable
mPlot( HELPrct, "histogram" )          
#Empieza con un histograma 
mPlot( HELPrct, "density" )            
#Empieza con un gráfico de densidad
mPlot( HELPrct, "frequency polygon" )  
# Empieza con un polígono de frecuencia
@


\begin{center}
	\includegraphics[width=3.8in]{images/mPlot}
\end{center}


\section{Shiny}

\pkg{shiny} es un paquete creado por el equipo de \RStudio, para en sus palabras,
\begin{quotation}
	[hacer] increíblemente fácil construir una aplicación web con R. 
	      Las ataduras "reactivas" automáticas entre las entradas y las salidas, y amplios 
	      widgets pre-fabricados hacen posible construir agradables, receptivas y poderosas 
	      aplicaciones con un esfuerzo mínimo.
\end{quotation}
Estas aplicaciones web pueden, obviamente, correr código de \R\ para hacer los calculos y producir gráficos que aparecen en la página web.

El nivel de habilidades de código requeridas para crear esto se encuentra fuera del alcance de este libro, pero aquellos con un bagaje más amplio en programación pueden facilmente aprender las herramientos necesarias para hacer páginas web interactivas agradables a la vista. Más información sobre shiny y algunas aplicaciones de ejemplo están disponibles en \url{http://www.r.studio.com/shiny/}.

\begin{problem}
El siguiente código hace un gráfico de dispersión con símbolos separados para cada sexo.
<<eval=FALSE>>=
xyplot(cesd ~ age, data=HELPrct, groups=sex)
@
Construya un ejemplo de \pkg{manipulate} que le permita habilitar y deshabilitar el agrupamiento con una checkbox.
\end{problem}

\begin{problem}
Construya un ejemplo de \pkg{manipulate} que use un seleccionador (picker()) para seleccionar de las variables que se tienen para hacer un gráfico. Aquí hay un ejemplo con un histograma

\medskip
\centerline{\includegraphics[width=3.8in]{images/manipulate-multihist}}
\end{problem}

\begin{problem}
Diseñe su propia idea de demostración interactiva e implementela usando las herramientas de \pkg{manipulate} en \RStudio
\end{problem}

\section*{Ejercicios}
\shipoutProblems


\backmatter

\bibliographystyle{alpha}
\bibliography{../include/USCOTS}

\printindex

\end{document}

